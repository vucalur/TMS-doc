\documentclass[a4paper,12pt,notitlepage]{mwrep}
%%\documentclass[polish,11pt,a4paper,twosides]{article}
%%%\usepackage{fullpage}

\usepackage{./mystyle}

\begin{document}

% footer only for title page:
\newcommand{\cfoottext}{Kraków, \today}
\renewcommand{\footrulewidth}{0.4pt}
\cfoot{\cfoottext}

\begin{titlepage}
\begin{center}
  \resizebox{\textwidth}{!}{\mbox{AKADEMIA GÓRNICZO-HUTNICZA}}\\
  \vspace{2ex}
  \resizebox{\textwidth}{!}{\mbox{Wydział Informatyki, Elektroniki i Telekomunikacji}}\\
  \vspace{4ex}
  \includegraphics[scale=0.15]{images/agh_crop.pdf} \\
  \vspace{4ex}
  \begin{large}KATEDRA INFORMATYKI\end{large} \\
  \vspace{8ex}
  \textbf{\begin{Huge}System prowadzenia zadań w projektach IT\end{Huge}} \\
  \vspace{3ex}
  \textit{\begin{Large}codename: \codename\end{Large}} \\

  \vspace{2cm}
  \begin{Large}\wersja\end{Large}\\
    \vspace{2cm}
\end{center}
\begin{large}
  \begin{tabularx}{\textwidth}{lXc}
    \textit{Kierunek, rok studiów} &  & \textit{ } \\
    \hspace{3em}Informatyka, rok III &  &  \\fram
    \textit{Przedmiot} &  & \\
	\multicolumn{3}{l}{\hspace{3em}Inżynieria Oprogramowania} \\
    \textit{Prowadzący przedmiot} &  & \textit{rok akademicki:} \hfill 2012/2013\\
    \hspace{3em}\minibox{dr inż. Małgorzata Żabińska-Rakoczy\\dr inż. Jarosław Koźlak} &  & \textit{semestr:} \hfill 6\\
  \end{tabularx}
\end{large}


\vspace{2ex}

\noindent
\begin{Large}
Skład zespołu:\end{Large}
\begin{large}
  \newlength{\tblwidth}
  \setlength{\tblwidth}{\textwidth}
  \addtolength{\tblwidth}{-3em}
  \begin{flushright}
    \begin{tabularx}{\tblwidth}{lXr}
      Grzegorz Wilaszek &  &  \\
      Wojciech Krzystek &  &  \\
    \end{tabularx}\end{flushright}
  \end{large}
  \thispagestyle{fancy}
\end{titlepage}



\onehalfspacing

\lhead{\footnotesize{Grzegorz Wilaszek, Wojciech Krzystek}}
\lfoot{\footnotesize{\codename}}
\cfoot{\normalsize Strona \thepage \ z \pageref{LastPage}}
\rfoot{\scriptsize{\wersja}}

%\setcounter{secnumdepth}{2}
%\setcounter{tocdepth}{2}	% 2 - ToC will contain only subsections


\vfill
\begin{center}
\singlespacing
\fbox{\begin{minipage}{0.8\textwidth}
\footnotesize Niniejsze opracowanie powstało w trakcie i jako rezultat zajęć dydaktycznych z przedmiotu 
wymienionego na stronie tytułowej, prowadzonych w Akademii Górniczo-Hutniczej w Krakowie
(AGH) przez osobę (osoby) wymienioną (wymienione) po słowach ,,Prowadzący przedmiot''
i nie może być wykorzystywane w jakikolwiek sposób i do jakichkolwiek celów, 
w całości lub części, w szczególności publikowane w jakikolwiek sposób
i w jakiejkolwiek formie, bez uzyskania uprzedniej, pisemnej zgody tej
osoby (tych osób) lub odpowiednich władz AGH.
\vspace{2ex} \\
\textbf{Copyright \textcopyright \the\year\ Akademia Górniczo-Hutnicza (AGH) w Krakowie}
      \end{minipage}
}
\onehalfspacing
\end{center}

\tableofcontents


\setcounter{page}{0}
\chapter{Wizja}




\section{Opis systemu}
System prowadzenia zadań w projektach IT ma być w pełni samodzielną (ang. standalone)
aplikacją webową ułatwiającą pracę w zespołach programistycznych (\href{http://en.wikipedia.org/wiki/Issue_tracking_system}{Ticket tracking system}).
Narzędzie sposobem działania będzie przypominało istniejące systemy, np: Redmine, Trac, Jira.\\
Użytkownicy będą mogli tworzyć zadania (ang. tickets, issues, tasks), zmieniać ich status, logować godziny.
Narzędzie służy monitorowaniu prac nad całym realizowanym przedsięwzięciem programistycznym jaki pracy poszczególnych członków zespołu.\\
System będzie tworzony “od zera”, nie będzie rozwinięciem istniejącej aplikacji,
jak i nie będzie korzystał z zewnętrzych zasobów (Web Servisy, itp.).\\	
Jako wzorce funkcjonalności jakich powinien dostarczać taki system obieramy
istniejące rozwiązania uzupełnione o autorskie pomysły.
Podstawą naszej koncepcji jest stworzenie aplikacji webowej, z której mogłyby korzystać różne zespoły:
firmy, instytucje oraz, może przede wszystkim, grupy niezależnych programistów zrzeszonych
w tworzeniu jakiegoś projektu, z szczególnym naciskiem na tworzenie tzw. otwartego oprogramowania
(ang. open source). Dostępne na rynku rozwiązania, nawet jeśli są darmowe, wymagają uruchomienia
aplikacji na własnym serwerze. Jest to oczywiście dużym plusem, jeśli chodzi o politykę prywatności
i bardzo odpowiada dużym firmom i organizacjom, jednak dla wielu projektów
(zwłaszcza w przypadku oprogramowania otwartego) takie rozwiązanie wydaje się być zbyt ciężkim,
czasochłonnym oraz pracochłonnym. Wysiłek poświęcony na skonfigurowanie środowiska jest zbędny
w przypadku mniejszych projektów. Znacznie lepiej byłoby móc założyć profil projektu na łatwo
dostępnym portalu i włączyć wszystkich członków zespołu do przedsięwzięcia. Umożliwołoby to także
łatwą organizację projektu bardzo małym zespołom, nawet grupom studentów pracyjących nad wspólnym projektem.\\
Dodatkowym atutem byłaby jednoczesna możliwość pobrania aplikacji i wykorzystanie jej na własnym serwerze.
Dzięki temu oprogramowanie byłoby postrzegane jako odpowiadające różnym wymogom bezpieczeństwa,
np. dzięki ukryciu wszystkich zasobów firmy za firewall’em.




\section{Motywacja}
Motywacją naszego pomysłu było zetknięcie się z dużymi systemami do zarządzania projektami:
\begin{description}
	\item[IBM Rational Team Concert]
		Jest to komercyjny projekt firmy IBM. Bardzo drogi,
		ale także o bardzo dużych możliwościach.
		Łączy zarządzanie projektem w metodologiach “zwinnych” (ang. “agile”)
		z systemem kontroli wersji. IBM udostępnia specjalną wersję
		Eclipse IDE (Rational Team Concert Eclipse) oraz wtyczki do zwykłego Eclipse’a.
		Pozwala na bardzo przejrzyste łączenie zadań z kodem w projekcie.
		Możliwości jest bardzo dużo. Najlepszym przykładem jest opcja zaznaczenie
		fragmentu kodu i sprawdzenia , przez kogo został dodany lub zmodyfikowany
		oraz częścią jakiego zadania były te zmiany. Wadą oprogramowania RTC jest
		przede wszystkim jego cena. Ponadto wymaga dużego nakładu administracyjnego,
		ponieważ ma wiele możliwości i parametrów do skonfigurowania.
		Nadaje się zatem tylko dla bardzo dużych firm. 
	\item[Redmine]
		Redmine jest darmowym i otwartym, webowym narzędziem do zarządzania projektami
		i śledzenia błędów. Zawiera kalendarz i wykresy Gantta do wspomagania wizualnego
		przedstawiania projektów i ich terminów. Obsługuje wiele projektów.
		Redmine zapewnia zintegrowane funkcje zarządzania projektami, śledzenie błędów
		i wsparcie dla różnych systemów kontroli wersji. Wyraźny wpływa na Redmine’a
		miał projekt \textbf{Trac}, pakiet o podobnych cechach. Redmine jest napisany
		z wykorzystaniem Ruby on Rails i wymaga uruchomienia na własnym serwerze.
		Jest to właśnie pierwszy aspekt, w któym chcemy wprowadzić pewną nowość
		przez skoncentrowanie usług na jednym portalu. Drugim elementem, gdzie
		chcemy wprowadzić innowacje, jest zasób narzędzi, gdyż Redmine nie oferuje
		wszystkich przydatnych sposobów graficznej prezentacji przebiegu projektu.
		Ogromną zaletą projektu Redmine jest oczywiści jego dostępność bez żadnych opłat
\end{description}
Są to dwa największe systemy, z którymi spotkaliśmy się podczas praktyk zawodowych.
Jakiś czas później, rozpoczynając nowe projekty uczelniane, szukaliśmy podobnych,
lecz lżejszych (i w przeciwieństwie do IBM Rational Team Concert - darmowych),
rozwiązań. Istnieją pewne szybkie w użyciu portale do prowadzenia projektów,
jednak nie są one skoncentrowane stricte na projektach informatycznych,
dlatego brakuje im wielu przyfatnych dla programistów funkcjonalności.
W obsługę zadań (ang. “tasks”, “issues”) są wyposażone niektóre hostingowe
serwisy internetowe przeznaczone dla programistów korzystających z kontroli wersji,
zwłazcza oprogramowania Git, takie bittbucket.org bądź github.org.
Ich wadą jest przede wszystkich niezbyt szeroki zakres funkcjonalności, na przykład:
\begin{itemize}
	\item	brak wyraźnego połączenia zadań z kodem (bitbucket)
	\item	brak możliwości oznaczania różnych parametrów zadań,
			np: priorytet, zagrożenie związane z błędem lub brakiem zaimplementowanej funkcjonalności (zwłaszcza github).
	\item	brak możliwości oznaczania zadań jako powiązane (np. relacja “rodzic - dziecko”)
\end{itemize}
Dodatkową wadą jest też oczywiście powiązanie danych projektu
(zadania, komentarzy itd.) z konkretnym repozytorium!
Z jednej strony jest oczywiście wyjątkowo mało elastyczne w pracy,
ale przede wszystkim pojawia się olbrzymi problem, jeśli chcemy przeniść
projekt do innego repozytorium (np. zrezygnować z otwartości projektu
a tylko taką opcję udostępnia github). Tracimy wówczas całą historię projektu.
Wszystkie zadanie, komentarze, wszystkie dane. Mimo to, wiele niedużych
zespołów wybiera zarządzanie projektami na takim serwisie, gdyż jest
to dla nich najprostsze wyjście. Chcielibyśmy, aby nasza aplikacja była
rozwiązaniem takiego problemu. Aby była elastyczna i prosta w użyciu.
Aby rozpoczęcie pracy nad nowym projektem trwało dosłownie chiwlkę.




\section{Innowacyjność}
Uważamy, że chociaż istnieje kilka rozwiniętych przedsięwzięć,
zajmujących się tą tematyką, wciąż można znaleźć luki do uzupełnienia
w puli tych rozwiązań. Naszym celem nie jest mierzenie w kompleksowość
usług na poziomie IBM Rational Team Concert, ale dodanie paru pomysłów
do rozwiązań w stylu oprogramowania Redmine. Chodzi głównie o wizualizację
parametrów pracy nad projektem, zwłaszcza tzw. “burn down chart” (brak popularnej polskiej nazwy).
Jest to bardzo przydatny wykres do monitorowania postępu prac w projekcie.
Analogicznym wykresem jest wykres przedstawiający ilość spodziewanych zgłaszanych
w czasie defektów z jednoczesną linią obrazującą rzeczywistą ilość raportowanych błędów.
Jest to bardzo ważne w technikach zwinnych (ang. “agile”) do analizy postępu i jakości pracy.




\section{Rodzaj aplikacji}
Nasza aplikacja, jak już wcześniej wspomnieliśmy, byłaby aplikacją webową z własną bazą danych.
Ważną cechą będzie możliwość uruchomienia centralnego serwisu internetowego,
z którego będą mogli koszystać wszyscy programiści na świecie. Będą mogli zakładać wiele projektów.
Z drugiej strony możliwe będzie pobranie aplikacji postawienie serwera z własną kopią serwisu,
dzięki czemu użytkownik będzie mógł ukryć wszystkie dane we własnej sieci i nie będzie
uzależniony od obciążenia centralnego serwisu. Jest dodatkowo istotnym czynnikiem
przy wyborze technologii, w której zaimplementujemy system. Musi być możliwe bardzo
lekkie uruchomienie środowiska (jak np. w Django bądź Play! Framework, przez wydanie
prostej komendy “run” w terminalu), ale jednocześnie muszą być dostępne wielkoskalowe
i wydajne rozwiązania, dostosowane do używania aplikacji przez tysiące użytkowników.
Musimy zatem wybrać technologię wspierającą oba warianty.




\section{Szczegółowa koncepcja}
Użytkownik będzie korzystał w przeglądarce WWW z webowego interfejsu aplikacji.
Odwiedzając stronę, będzie miał początkowo do czynienia z funkcjonalnością opisaną w następującym podpunkcie.

\subsection{Pierwsze kroki użytkownika w aplikacji}
Wchodząc na stronę internetową, użytkownik zobaczy panel logowania.
Niezalogowany użytkownik będzie miał dostęp praktycznie tylko do tej podstrony.
Ewentualnie, będzie miał kilka dostępnych zakładek z informacjami o produkcie,
danymi kontaktowymi, czy też z formularzem rejestracyjnym. Samo istnienie funkcjonalności
rejestracji użytkowników jest do rozpatrzenia. Można rozważyć udostępnienie uwierzytelniania
poza naszym serwisem, na przykład za pomocą kont mailowych na gmail’u.

\subsection{Organizowanie nowego projektu}
Zalogowany użytkownik będzie mógł założyć nowy projekt. Będzie mógł podać
różne dane opisowe tego projektu: wykorzystywane technologie, przewidywany
czas realizacji itp. Ponadto, będzie mógł zapraszać osoby do projektu
a także przyjmować wnioski użytkowników o nadanie praw do wprowadzania zdarzeń w projekcie. 

\subsection{Kamienie milowe}
Ważnym zagadnieniem są kamienie milowe. Do nich będą przyporządkowywane zadania.
Kamienie milowe będą miały swoje daty realizacji. Można przewidzieć hierarchiczną
strukturę zbioru kamieni milowych. Dzięki temu będzie można przykładowo wyznaczyć
półroczny kamień milowy w projekcie i dodatkowo podzielić go na dwu tygodniowe
sprinty, które de facto też będą kamieniami milowymi.

\subsection{Dodawanie nowych zadań}
Użytkownik posiadający uprawnienia do zmian danym projekcie,
będzie mógł dodawać do projektu nowe zadanie. Przewidujemy podstawowe typy zadań, takie jak: 
\begin{itemize}
	\item	zwykłe zadanie
	\item	defekt
	\item	test
	\item	dokumentacja
	\item	ulepszenie
\end{itemize}
Innymi parametrami zadania będzie przewidziany czas (lub data) jego wykonania,
kamień milowy, do którego należy, osoba, która wykonuje to zadanie.
Zadanie będzie także miało swój stan: początkowe będzie otwarte bądź zamknięte.
Później można się także zastanowić nad bardziej szczegółowymi możliwościami.

\subsection{Przeglądanie zadań}
Użytkownik będzie mógł przeglądać zadania z danego projektu.
Będą one wyświtlone w formie interaktywnej listy z możliwością sortowania
oraz filtrowania po podstawowych parametrach: na przykład po kamieniach milowych,
po priorytecie, statusie itp. W tym samym widoku będzie można dodać nowe zadanie
lub usunąć inne. Ten element jest podstawą przejrzystości aplikacji i musi
być wykonany czytelnie, udostępniając intuicyjny i czytelny interfejs.

\subsection{Edytowanie zadania}
Edytowanie zadań obejmować będzie dodawanie komentarzy oraz linków do kodu.
Będzie można zmieniać parametry zadania, takie jak przewidywana data oddania,
osoba pracująca nad zadaniem. W szczególności będzie też można zakończyć zadanie,
zamykając je poprzez wciśnięcie odpowiedniego przycisku.




\section{Użyte technologie}
Całość aplikacji będzie zrealizowana w technologiach Javowych i pokrewnych.

\subsection{Warstwa persystencji}
\subsubsection{Baza danych}
Wybór systemu zarzadzania bazą danych jest prosty: zostanie użyta baza PostgreSQL,
ze względu na:
\begin{itemize}
	\item	darmowość narzędzia
	\item	rozbudowane funkcjonalności (w porównaniu do “lekkich” DMBS, jak np: MySQL, SQLite, HSQL) - nie odstępuje produktom komercyjnym
	\item	dobra wydajność (ustępuje jedynie rozwiązaniom komercyjnym, np: Oracle DB)
	\item	bardzo dobra kompatybilność z frameworkami ORM
	\item	dopracowane i bogate w funkcjonalności narzedzie graficzne do bezpośredniego zarządzania bazą - pgadmin3
\end{itemize}

\subsection{Serwer aplikacji - kandydaci}
\begin{itemize}
	\item	Glassfish
	\item	Tomcat
	\item	TomEE
\end{itemize}
Wybierając serwer będziemy kierowali się prostotą obsługi, popularnością, jakością dokumentacji.\\
Wybór serwera aplikacji może zostać dokonany później.

\subsection{Warstwa prezentacji - kandydaci}
\begin{itemize}
	\item	\textbf{Spring MVC}
	\item	\textbf{GWT / Vaadin / GXT}\\
			Rodzina technologii (GWT jest jej prekursorem, GXT oraz Vaadin to rozszerzenia)
			pozwalająca tworzyć bogate aplikacje webowe (RIA) bezpośrednio w języku Java,
			korzystając z wygodnego API.\\
			Taki wysokopoziomowy kod pośredni jest następnie kompilowany przez framework do
			technologi docelowej - JavaScript.\\
			Warto wspomnieć, iż GXT i Vaadin różnią się technologicznie - Vaadin realizuje
			koncepcję cienkiego klienta, GXT - grubego (większość akcji jest kompilowana
			do dynamicznego JavaScriptu przeznaczonego na przeglądarkę klienta).
	\item	Play! framework (wersja dla Javy)
\end{itemize}
W warstie prezentacji zostało wyszczególnionych wiele kandydatów
do bycia technologią docelową. Po głębszym zapoznaniu się z technologiami i wstępnych próbach
zostanie podjęta decyzja.\\
Rozważamy również utworzenie aplikacji w frameworku “lekkim”, np: Django, Ruby On Rails.\\
Niezależnie od wybranej w tej w warstwie technologii, będzie ona bazowała
(będzie zrealizowana “pod maską”) na technologii JavaScript, dotyczy to również
technologii opartych na językach innych niż Java.

\subsection{Technologie - ostateczny wybór}
Po szczegółowej analizie przedstawionych wyżej możliwości, zdecydowaliśmy,
że zrealizujemy projekty w technologii Play! Powody naszego wyboru są następujące:
\begin{itemize}
	\item	Framework Play! jest prosty i nowoczesny. Jest uważany za przełom w świecie Javy.
			Łączy wydajność z prostotą. Jest postrzegany jako bardzo przyjazny dla programistów.
			Proponuje bardzo ciekawe rozwiązania, które już na pierwszy rzut oka pokazują,
			że technologia umożliwia pisanie krótszego i bardziej czytelnego kodu w najbardziej
			popularnym języku programowania - Javie. Jest to osiągnięte przez rezygnację
			z pewnych standardów programowania w Javie.
	\item	Możliwości uruchomienia serwera aplikacji są bardzo elastyczne i dostosowane
			do naszych (wyżej opisanych) potrzeb. 
	\item	Play! Framework do persystencji domyślnie używa biblioteki Avaje Ebean. Jest to framework 
			bazujący na adnotacjach JPA, dostarczający interfejs znacznie wyższego poziomu niż 
			implementacje JPA, takie jak Hibernate. Znacznie prostsza jest tranzakcyjność, pisanie 
			zapytań a także wiele możliwości dostarczają adnotacje dla persystentnych pól, dodając 
			na przykład kontekst szyfrowania tajnych danych.
	\item	Framework obsługuje dwa języki programowania: Java i Scala. Można pisać kod w obu językach w ramach 
			jednego projektu. Daje to bardzo duże możliwości, jako że Java jest językiem niezwykle 
			popularnym, a Scala nowoczesnym i mającym duże perspektywy. 
 
\end{itemize}
Framework Play! jest dostępny w dwóch wersjach: dla języka Scala (pracującego na wirtualnej
maszynie Javy) oraz dla samej Javy. Zdecydowaliśmy się, póki co, na tę drugą opcję, ponieważ:
\begin{itemize}
	\item	Można łatwo wykorzystywać inne bibloioteki i technologi, chociażby takie jak Spring
	\item	Sami mamy większe doświadczenie w Javie
	\item	Łatwiej jest korzystać z technologi wykorzystywanych przez Play!, np. Hibernate
	\item	Biorąc pod uwagę perspektywę rozbudowy systemu, łatwiej będzie wdrożyć się nowym programistom,
			jeśli aplikacja będzie napisana w Javie
\end{itemize}

\subsection{Baza danych}
Wybraliśmy bazę danych PostgreSQL ze względu na jej bardzo dobre opinie. Jest uważana za najlepszy darmowy system zarządzania 
bazą danych. Jednakże, w fazie deweloperskiej będziemy korzystać z bazy danych H2, bazy przetrzymującej dane w pamięci. Play! 
Framework zapewnia bardzo łatwe przełączanie między rzeczywistą bazą danych a atrapą H2. Dodatkowo, bazy danych H2 będziemy 
używać do testów automatycznych.

\subsection{Dodatkowe biblioteki}
Kolejnymi, po wyborze głównych technologii, technicznymi wyborami były dodatkowe, wspomagające biblioteki. Na razie 
będziemy potrzebować głównie komponentów graficznych. I tak zdecydowaliśmy się na następujące:
\begin{itemize}
	\item	jTable - biblioteka oparta na jQuery, służąca do prezentacji danych w interaktywnych tabelach. Głównym 
		zastosowaniem będzie z pewnością tabela z zadaniami, ale także z pracownikami projektu czy kamieniami 
		milowymi.
	\item	Highcharts JS - JavaScript'owa biblioteka do prezentacji danych na wykresach. Dostarcza wiele rodzajów 
		wykresów, także interaktywnych. Przydadzą się nam one do prezentowania analiz pracy w projekcie.
	\item	Twitter Bootstrap - biblioteka komponentów HTML, CSS oraz JavaScript do szybkiego tworzenia ładnych i nowoczesnych 
		interfejsów webowych.
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{images/jTable.png}
\caption{Przykładowa tabela CRUD generowana przez jTable}
\label{fig:jTable}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{images/highCharts.png}
\caption{Przykładowy wykres wykonany przy użyciu biblioteki Highcharts JS}
\label{fig:highCharts}
\end{figure}



\section{Zarys architektury}
Przedstawiamy wstępny zarys architekruty systemu. Jest on w dużej mierze podyktowany przez archutekturę technologii Play! Framework. 
Warto także zwrócić uwagę na sposób zwracania rezultatu do przeglądarki klienta. Będzie się odbywała standardowo - przez generowane 
widoki, ale także przez pobieranie danych przez web serwisy - np. w formacie JSON.

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{images/tasksArch.jpg}
\caption{Architektura systemu}
\label{fig:tasksArch}
\end{figure}


\section{Plan działania}
Projekt będzie realizowany w metodologii lekkiej - będziemy chcieli początkowo
zrealizować jedynie podstawowe funkcjonalności takiego systemu, stopniowo dobudowywyjąc
nowe i zwiększając możliwości starych.\\
Pozwoli nam to na lepszą estymację czasu potrzebnego na zrealizowanie dalszych funkcjonalności,
jak i czasu realizacji całego przedsięwzięcia.
\\
\\
Zakładając, że projekt będzie trwał do 15-25 czerwca, przyjęliśmy na początku następujący harmonogram:
\begin{itemize}
	\item	29/04/13 - logowanie i rejestracja
	\item	06/05/13 - panel użytkownika
	\item	13/05/13 - dodawanie projektu i kamieni milowych
	\item	20/05/13 - dodawanie zadań
	\item	27/05/13 - dodawanie współpracowników,
	\item	przypisywanie roli administratora współpracownikowi
	\item	10/06/13 - panel zadania: komentarze, zmiana stanu
		zadania
	\item	17/06/13 - kilka przykładowych wykresów

\end{itemize}




\section{Wymagania -- etap 1}
Etap ma za zadanie dostarczenie stosunkowo szybko “czegoś działającego” do klienta,
jak również potwierdzenie wykonalności całego zadania.\\
Jednym z ważnych podcelów tego etapu będzie decyzja co do używanej technologii.
\paragraph{Funkcjonalne}
\begin{itemize}
	\item	W pełni działający mechanizm kontroli dostępu oraz podział użytkowników na role
	\item	Formularz zakładania nowego projektu
	\item	formularz tworzenia nowego taska
	\item	formularz edycji istniejącego taska
	\item	lista --- widok wszystkich tasków, z ew. sortowaniem
	\item	Widok wszystkich projektów danego użytkownika
\end{itemize}
\paragraph{Niefunkcjonalne}
\begin{itemize}
	\item	brak autentykacji, brak kontroli dostępu do systemu (w zależności od terminu
			oddania pierwszego prototypu możliwość zrezygnowania z tego ograniczenia)
	\item	system działający już na własnej bazie
	\item	niekoniecznie gotowa konfiguracja środowiska produkcyjnego --- pokaz na środowisku deweloperskim
	\item	brak testów jednostkowych oraz akceptacyjnych, brak podejścia TDD na tym etapie
\end{itemize}




\section{Wymagania -- etap 2}
\paragraph{Funkcjonalne}
\begin{itemize}
	\item	rozbudowane filtry w liście wszystkich tasków
	\item	widok użytkowników systemu = pracowników danego projektu
	\item	dodawanie komentarzy do taska
	\item	panel admina --- zarzadzanie projektem, zapraszanie użytkowników do projektu, itp.
\end{itemize}
\paragraph{Niefunkcjonalne}
\begin{itemize}
	\item	autentykacja
	\item	bardziej rozwinięta warstwa pośrednia (middleware)
	\item	testy jednostowe do niektórych funckjonalności
	\item	dopracowany wygląd graficzny aplikacji
\end{itemize}




\section{Przykładowe dalsze możliwości rozbudowy}
Temat prowadzenia projektów jest bardzo szeroki, dlatego nasz projekt ma ogromne możliwości
rozbudowy w przyszłości. Część z przedstawionych pomysłów zostanie zrealizowana.
Nic nie stoi na przeszkodzie, aby pozostałe propozycje zostały kiedyś zrealizowane przez
inne zespoły, bądź przez nas w ramach innych przedmiotów. W skrócie:
\begin{itemize}
	\item	cykl życia tasków, np: new $\rightarrow$ assigned $\rightarrow$ in progress $\rightarrow$ rejected
			z walidacją poprawności obieranych przez taski stanów
	\item	dodatkowe klasyfikowanie tasków, np: priorytet, tagowanie numerem podgrania, własne tagi
	\item	raportowanie czasu do poszczególnych tasków
	\item	miesięczne statystyki czasu
	\item	hierarchia tasków (rodzic, dziecko)
	\item	estymaty czasowe, wykresy:
			\begin{itemize}
				\item	\href{http://www.youtube.com/watch?v=XU0llRltyFM&t=4m29s}{Burndown chart} (pierwszy prototyp zrealizowany)
				\item	monitoring ilości tasków - podział na otwarte i zamknięte (analogcznie jak jest to zrealizowane w narzędziu JIRA:
						\href{https://confluence.atlassian.com/download/attachments/185729486/gadgets-charting-created-vs-resolved.png?version=2&modificationDate=1350347163816&api=v2}{link})
			\end{itemize}
	\item	powiadamianie email, kanały RSS
	\item	rejestracja poprzez emaila aktywacyjnego
	\item	zaawansowany interfejs graficzny, np: avatary użytkowników, itp.
\end{itemize}


\subsection{Organizowanie nowego projektu}
Mając na uwadze potencjalne możliwości rozszerzania projektu w przyszłości,
warto przewiedzieć możliwość dodawania zespołów w projekcie(np. zespół programistów,
testerów bądź bardziej szczegółowy podział). Można również dodać możliwość wyznaczania
w projekcie komponentów lub obszarów. Dalej idąc, można przewidzieć opcję wyznaczenia osoby
odpowiedzialnej za komponent czy też obszar. Ułatwia do współpracą i przyspiesza uzyskania
pomocy w razie wątpliwości, kiedy to inny pracownik pracuje nad tym obszarem projektu.
Ciekawym urozmaiceniem jest także stworzenie możlwiwości dodawania własnych tagów dla projektów.
Przykładowo, jeśli projekt ma wdrożony w najbliższej przyszłości, część zadań można oznaczyć tagiem,
sugerującym, że zadania te są równie ważne jak pozostały, jednak z pewnych względów przewiduje się ich
realizację dopiero w kolejnej wersji produktu.


\subsection{Kamienie milowe}
Kamienie milową są ważną jednostką organizacyjną projektu, dlatego warto wzbogacić je o dodatkowe
wizualizacje i diagramy. Przykładowo procent wykonania przewidzianych zadań itp.


\subsection{Dodawanie nowych zadań}
Ważnym dodatkiem jest stworzenie hierarchicznej budowy zadań.
Tak, aby można było oznaczyć inne zadanie jako rodzic nowego zadanie itp. Możliwe jest
wzbogacenie ilości stanów zadania (np. nowe, oczekujące, w trakcie pracy itp.) Poza tym,
jeśli projekt będzie posiadał swoje obszary lub komponenty, to również zadanie mogłoby mieć
przyporządkowan obszar lub komponent, którego dotyczy. Mogłoby także istnieć dodatkowe pole
na zespół, który ma się zająć tym zadaniem. Dzięki temu odpowiednie osoby szybciej je zobaczą,
natomiast te, które nie mają się nim zajmować, być może w ogóle nie zwrócą na nie uwagi,
ponieważ będą tylko patrzeć na własną kolejkę zadań. Dodatkowo, można w zadaniu przewidzieć
dodatkowe pole na osobę pierwszego kontaktu, byłby to np. programista, która niedawno zajmował
się podobnymi sprawami, ale nie jest odpowiedzialny za dany obszar lub komponent, albo osoba mają
duże doświadczenie w powiązanej z zadaniem technologii.


\subsection{Przeglądanie nowych zadań}
Udostępnienie w systemie dodatkowych atrybutów zadań pozwoli na wzbogacenie srotowania i filtrowania
o te parametry. Można także umożliwić użytkownikom tworzenie własnych, nazwanych kolejek zadań
(prywatnych lub dla całego projektu). Przykładowo, główny architekt systemu dodałby nazwaną kolejkę
“najważniejsze zadania”, która pokazywałaby wszystkie zadania o najwyższym priorytecie, największym
zagrożeniu dla projektu oraz przeznaczący na bieżący kamień milowy (np. sprint).


\subsection{Edytowanie zadania}
Podobnie, jak w poprzednich podpunktach, tutaj także możliwości będą rozbudowane wraz z rozbudową
funkcjonalności systemu oraz przybywaniem nowych właściwości zadań. Dodatkowo, można wprowadzić dodatkowe
stany cyklu życia zadania, takie jak “potrzebuję informacji” (np. deweloper oznacza tak zadanie
i przypisuje je do testera, który zgłosił defekt, aby udzielił bardziej szczegółowej informacji)
oraz “Rozwiązane”, do któego z kolei można będzie przydzielić dodatkowe informacje (np. oznaczyć,
że to zadanie było duplikatem innego zadanie i podać powiązane zadanie). Można także przewidzieć
dodawania linków do zmian w kodzie wprowadzonych wraz z pracą nad tym zadaniem (np. link do commit’u
na githubie). W bardziej zaawansowanej wersji można dobudować bardziej profesjonalny \textbf{moduł integracj
iz systemami kotroli wersji}.


\subsection{Nowe narzędzie w projekcie}
Jeśli system osiągnie kiedyś wysoki poziom rozwinięcia i zaawansowanie, co oznacza zaimplementowanie
w zasadzie wszystkich funkcjonalności wspomnianych w powyższych podpunktach, będzie można zastanowić
się nad dodaniem kolejnych możliwości, już na zasadzie osobnych narzędzi. Podajemy kilka przykładów,
jakie mogłyby to być programy. Propozycje są bardzo luźne i nie zastanawialiśmy się, jak bardzo
złożone byłyby to projekty:
\begin{itemize}
	\item	Wtyczka do Eclipse’a (lub innego popularnego IDE)
	\item	Zaawansowana synchronizacja z systemem kontroli wersji (być może zsynchronizaowana z wtyczką do IDE)
	\item	Aplikacja do obsługi repozytorium w stylu Tortoise Git / Tortoise SVN, umożliwiające dostęp do
			repozytorium z jednoczesnym podpięciem do naszego systemu zarządzania zadaniami
	\item	Narzędzie linii poleceń analogiczne do powyższego
\end{itemize}






\chapter{Specyfikacja logiki aplikacji}
\section{Przegląd istniejących rozwiązań}
\subsection{IBM Rational Team Concert}
Narzędzie IBM RTC oferuje bardzo szerokie możliwości administracji i zarządzania projektem. Jeśli natomiast chodzi o interesujące nas funkcjonalności, Rational Team Concert ma następujące właściwości:
\begin{itemize}
	\item	Użytkownik widzi tylko te projekty, które zostały mu udostępnione przez administratorów projektów. Wcześniej musiał się zalogować. RTC udostępnia wiele mechanizmów uwierzytelniania użytkowników (np. LDAP, osobna baza danych, OAuth itp.)
	\item	Użytkownik otrzymywał prawo dostępu do projektu wówczas, gdy dostał zaproszenie od administratora.
	\item	Użytkownik, w ramach przynależności do projektu, mógł należeć do jednego z zespołów pracujących w projekcie. Można zabronić pracownikom jednego zespołu przypisywania się do zadań przeznaczonych dla innego zespołu, a nawet oglądania tych zadań. Takie restrykcje sprawdzają się w bardzo dużych projektach.
	\item	Mając dostęp do zadania, każdy mógł dodawać komentarze.
	\item	Pewne inne atrybuty zadania (np. priorytet, powiązane komponenty itp.) mogą być modyfikowane przez wszystkich pracowników projektu lub przez wybraną ich część, na przykład: dla zadań będących własnością zespołu ,,A'', których termin oddania jest krótszy niż tydzień, priorytet mogą zmienić tylko menedżerowie i administrator projektu. Daje to oczywiście duże możliwości, ale jednocześnie jest bardzo skomplikowane.
	\item	Zamknąć zadanie może jego właściciel lub inna upoważniona osoba, jeśli zadanie było oznaczone jako ,,completed''(ukończone). Było to ba przykład przydatne, gdy ktoś skończył zadanie, ale nie dostał jeszcze zgody na dostarczenie kodu i właśnie wybiera się na urlop. Często tą opcję wykorzystują studenci, których często nie ma w pracy np. cztery dni pod rząd.
\end{itemize}

\subsection{Redmine}
\uwaga{Poniżej przedstawiono jedynie opis poszczególnej instalacji i konfiguracji systemu Redmine
wykorzystywanej do prowadzenia wielu projektów w małym (kilka osób) zespole programistów
--- Redmine udostępnia rozbudowane możliwości a sposób
w jaki system będzie skonfigurowany jest czynnikiem kształtującym w największej mierze późniejszy
schemat interakcji użytkowników z systemem (łac. \emph{Modus operandi}).\je
Z jednej strony mamy możliwość skonfigurowania systemu według własnych potrzeb, z drugiej strony
nie jest to rozwiązanie w duchu ''\emph{out of the box}''}\de
\begin{description}
	\item[Role użytkowników]
		Role w systemie Redmine dzielą się na:
		\begin{itemize}
			\item	związaną z zarządzaniem samym Redminem: administrator
			\item	role pełnione przez użytkownika w danym projekcie, np:  developer, tester, manager
		\end{itemize}	związaną z zarządzaniem 
		Użytkownik może w danym projekcie mieć wiele ról. Administrator może dodatkowo pełnić role w projektach.
	\item[Uprawnienienia użytkowników]
		Administratorzy mają nieograniczone prawa -- mogą np: zarządzać projektami nieutworzonymi przez siebie,
		czy też usuwać konta innych użytkowników, w tym administratorów.\je
		Tworzyć, modyfikować oraz usuwać projekty może tylko administrator.
		W obrębie jednego projektu wszyscy użytkownicy mogą tworzyć, edytować, zamykać a nawet usuwać
		dowolne zadania. Wszyscy mogą komentować zadania, zmieniać właściciela, testera, zleceniodawcę
		tasków w projekcie, do którego jest zapisany (pełni jakąś rolę).\\
		Każdy ma dostęp odczytu (ale nie zapisu) tasków we wszystkich projektach.\\
		\uwaga{Redmine zapewnia dużo większe możliwości konfiguracji, drobnoziarnistości
		uprawnień, itp. Tutaj przybliżono opis działania pojedynczej instalacji Remdine'a z jaką przyszło nam pracować.}
	\item[Grupowanie tasków]
		Taski przynależą do jednego konkretnego projektu. Nie da się utworzyć tasków nieposiadających
		macieżystego projektu, ani takich które należą do wielu projektów
	\item[Cykl życia tasków]
		Redmine dostarcza w tym zakresie duże możliwości konfiguracji ---
		to administrator zakładając dany projekt określa nazwy stanów tasków, oraz możliwych przejść między nimi.
	\item[Taski]
		Task może mieć pojedycznego wykonawcę (asignee) lub być przypisany do grupy --- jest to jednak rozwiązanie niewygodne,
		gdyż trzeba specjalnie tworzyć grupę.
		Task może na tej samej zasadzie mieć przypisanego testera oraz zleceniodawcę.
		Dowolny użytkownik mający dostęp do projektu danego taska\footnote{Czyli inaczej: pełniący pewną rolę w danym projekcie}
		może doliczać do niego godziny pracy.
	\item[Nawigacja]
		Po zalogowaniu się użtkownik ma dostępne widoki między innymi:
		\begin{itemize}
			\item	Swojej karty czasu pracy
			\item	Widok projektów, do których jest przypisany\\
					Po wybrani danego projektu mamy widok użytkowników w projekcie, zadań, itp.
			\item	Panel użytkownika - edycja danych, preferencji, itp.
		\end{itemize}
	\item[Zarządzanie użytkownikami]
		Tworzyć użytkowników może tylko administrator. Przypisywać role użytkownikom w danym projekcie -- w zależności
		od konfiguracji -- można zablokować taką możliwość, wtedy przypisywaniem ról w projektach zajmuje się jedynie administrator.
	\item[Aspekty techniczne]
		W przypadku usuwania danych jedyny ślad pozostaje po nich w logach aplikacji.
		Użytkownicy mają jednakże możliwość tworzenia kopii zapasowych całego stanu systemu,
		oraz eksport danych danego projektu, zadania, itp. do pliku.
\end{description}




\section{Przyjęte przez nas rozwiązanie}
Nasz system nie będzie konfigurowalny w sposób w jaki konfigurowalne są dwa systemy przedstawione wyżej,
tracimy na uniwersalności, za to użytkownik nie zostaje zniechęcony trzystustronową dokumentacją
samego narzędzia oraz godzinami potrzebnymi na skonfigurowanie systemu do własnych potrzeb.\\
Zamiast tego chcemy dostarczyć produkt, który z domyślnymi ustawieniami adresuje potrzeby dużej rzeszy małych zespołów.\te
Wizja funkcjonalność dla pierwszej iteracji:
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{images/use_case_1.png}
\caption{Diagram przypadków użycia systemu}
\label{fig:use_case_1}
\end{figure}

\subsection{Logika aplikacji}
\subsubsection{Konta użytkowników}
\begin{itemize}
	\item	System swoim działaniem będzie przypominał serwisy do hostingu kodu źródłowego, np: bitbucket, github.
	\item	Każdy będzie mógł założyć konto oraz założyć swój projekt.
			Logowanie na nieistniejący login jest traktowane jako rejestracja.
	\item	Właściciel będzie mógł zaprosić do pracy nad projektem innych użytkowników.
	\item	Role i użytkownicy są oddzielnymi bytami -- role danego użtkownika są osobne dla każdego projektu.
			Użytkownik może nie mieć żadnych roli do danego projektu.
	\item	Nie istnieje rola administratora systemu.
\end{itemize}

\subsubsection{Role Użytkowników}
\begin{itemize}
	\item	Brak podziału na role tester, developer, itp. w kontekście projektu.
			Jeśli jest potrzeba przetestowania pewnej funkcjonalności spisuje się na to osobnego taska,
			osoba go realizująca jest tym samym \emph{testerem} tej funkcjonalności.
	\item	Właściciel projektu jest jego administratorem. Administratorzy projektu mogą nadawać innym
			użytkownikom w projekcie rolę administratora.
	\item	Administrator może odebrać uprawnienia do projektu innym użytkownikom, w tym administratorom,
			także sobie. Wyjątkiem jest właściciel projektu: nie mogą mu być odebrane prawa administratora danego projektu.
	\item	Jest przetrzymywana i wykorzystywana informacja o tym kto dany projekt założył (\emph{właściciel})
\end{itemize}

\subsubsection{Cykl życia tasków}
\noindent
Jest stały i określony z góry przez twórców aplikacji.\\
Jako możliwość rozbudowy można dodać możliwość ustanawiania cyklu życia tasków per projekt.

\subsubsection{Prawa dostępu}
\begin{itemize}
	\item	Wszystkie projekty są prywatne - prawa odczytu mają jedynie użytkownicy zaproszeni
	\item	Zapraszać użytkowników mogą jedynie administratorzy danego projektu.
	\item	Użytkownicy mogą edytowac wszytkie zadania w danym projekcie, także nie swoje
	\item	Istnieje widok przepracowanego czasu pracy przez danego pracownika.\\
			Każdy ma do niego wgląd, nie tylko dany pracownik
\end{itemize}

\subsubsection{Taski}
\begin{itemize}
	\item	Brak podziału na role tester, developer, itp. w kontekście projektu.
			Jeśli jest potrzeba przetestowania pewnej funkcjonalności spisuje się na to osobnego taska,
			osoba go realizująca jest tym samym \emph{testerem} tej funkcjonalności.
	\item	Właściciel projektu jest jego administratorem. Administratorzy projektu mogą nadawać innym
			użytkownikom w projekcie rolę administratora.
	\item	Administrator może odebrać uprawnienia do projektu innym użytkownikom, w tym administratorom,
			także sobie
	\item	Jest przetrzymywana i wykorzystywana informacja o tym kto dany projekt założył (\emph{właściciel})
	\item	Doliczać godziny do danego tasku może tylko jego wykonawca
	\item	Task ma tylko i wyłącznie jednego wykonawcę
\end{itemize}


\subsection{Interfejs graficzny}
Będą dostępne następujące widoki:
\begin{itemize}
	\item	Lista projektów użytkownika
	\item	Lista tasków w projekcie
	\item	Panel administracji projektem, np: zapraszanie użytkowników,
			nadawanie zaproszonym użytkownikom praw administratora
	\item	Widok taska z komentarzami
	\item	Edycja taska, dodawanie komentarza
	\item	Widok przepracowanych godzin przez danego pracownik projektu
\end{itemize}


\chapter{Wzorzec MVC w frameworku Play}

\section{Ogólny zarys}
Aplikacje w frameworku Play działają w oparci o wzorzec MVC zastosowany do architektury aplikacji webowych.

Zastosowane podejście rozdzila aplikację na 2 oddzielne warstwy:
\begin{itemize}
	\item	warstwa Prezentacji
	\item	warstwa Modelu danych
\end{itemize}
Warstwa prezentacji dzieli się dalej na warstwy Widoku i Kontrolera.

\begin{figure}[H]
\centering
\includegraphics[scale=0.7]{images/diagrams_mvc.png}
\caption{Wysokopoziomowa obsługa zdarzenia HTTP w architekturze MVC}
\label{fig:mvc_1}
\end{figure}

\begin{description}
	\item[Model]	Model jest obiektem encyjnym reprezentującym informacje, na których operuje warstwa biznesowa aplikacji.
		Logika biznesowa nadaje znaczenia gołym danym (np: wyliczanie kiedy dany pracownik ma urodziny,
		wyliczanie kwoty podatku, czy też kosztów przewozu zakupów w koszyku).\\
		Pomimo iż większość aplikacji używa baz danych jako mechanizmu utrwalania danych, architektura MVC nie wymusza,
		nie uzależnia się od takiego podejścia --- to jak dane sa pozyskiwane pod maską jest odgrodzone od samego MVC poprzez interfejs modelu.
	\item[Widok]	Widok renderuje model, tj. przetwarza na format wygodny do interakcji w interfejsie użytkownika.\\
		Ponieważ brak silnego powiązania (jeden z postulatów architektury MVC) relacji widok $\longleftrightarrow$ model,
		może istnieć wiele niezależnych od siebie widoków przeznaczonych do różnych celów.\\
		W aplikacji webowej model jest zazwyczaj transformowanych do formatu ,,weobwego'', np: HTML, XML, JSON.
	\item[Kontroler]	Kontroler reaguje na zdarzenia (akcje użytkownika) i procesuje je. Dodatkowo może wywoływać akcje
		na modelu i żądać ich utrwalenia.\\
		W aplikacji zdarzeniami sa najczęściej metody HTTP, w szczególności GET oraz POST.\\
		Kontroler nasłuchuje zdarzeń HTTP, wyciąga z nich odpowiednie dane, np": parametry, nagłówkim, ciała HTTP,
		oraz pobiera dane/wywołuje odpowiednie akcje na warstwie modeli.
\end{description}

\vspace*{1cm}
\noindent
W aplikacji play kod odpowiadający tym trzem warstwom znajduje się z katalogu app.

\section{Cykl życia requestu HTTP}

Play framework jest w pełni bezstanowy -- zorientowany tylko na cykl REquest-Response.

\begin{figure}[H]
\centering
\includegraphics[scale=0.7]{images/diagrams_path.png}
\caption{Obsługa przez aplikację requestu HTTP}
\label{fig:mvc_2}
\end{figure}


Opis powyższego schematu --- Ścieżka przejścia requestu HTTP:
\begin{enumerate}
	\item	Zwykły request HTTP wydawany przez klienta jest przejmowany przez aplikację.
	\item	Komponent Router znajduje najbardziej pasujący do requestu wzorzec, który mógłby
		obsłużyć dany request. Metoda kontrolera definiująca dany wzorzec jest wybierana.
	\item	Kod danej metody jest wykonywany.
	\item	Jeśli jest potrzeba zwrócenia poszczególnego widoku, wywoływany jest renderer.
	\item	Rezultat metody jest zwracany jako HTTP response.
\end{enumerate}

\chapter{Architektura systemu}

\section{Struktura aplikacji}
Jak już wcześniej wspomnieliśmy, architektura aplikacji jest podyktowana przez technologię Play! Framework. Jest to 
typowa technologia webowa oparta o wzorzec Model-View-Controller. Stąd też biorą się podstawowe nazwy pakietów: models, 
views orac controllers. \\
\begin{figure}[H]
\centering
\includegraphics[scale=1.0]{images/tasksArch.jpg}
\caption{Architektura systemu}
\label{fig:tasksArch}
\end{figure}

Aplikacja ma następującą strukturę katalogów:

\begin{itemize}
	\item	app - główny katalog źródłowy	
		\begin{itemize}
			\item	models - modele obiektów presystowanych. Są to klasy rozszerzającę klasę Model z framework'a
				Play! oraz oznaczone adnotacją @Entity. Są tam także Enumy i klasy pomocnicze, które są 
				persestowane wewnątrz klas @Entity.
			\item	views - widoki html'owe w plikach *.scala.html. Są to pliki korzystające z PLay'owego mechanizmu 
				,,Template Engine''. Silnik szablonów wykorzystuje język Scala (nie ma wersji template'ów dla Javy).
			\item	controllers - kontrolery rozszerzające play'ową klasę Controller.
			\item	security - pakiet klas odpowiedzialnych za bezpieczeństwo aplikacji i ochronę przed 
				nieupoważnionym dostępem. Komponent korzysta z mechanizmów Play! Framework i implementuje interferjsy, 
				dzięki którym można chronić dostęp do kontrolera przez dodanie adnotacji.
			\item	Global.java - klasa z ustawieniami globalnymi aplikacji.	
		\end{itemize}
	\item	conf - konfiguracja aplikacji webowej
		\begin{itemize}
			\item	application.conf - ustawienia aplikacji, takie jak konfiguracja połączenia z bazą danych, 
				czy też klucz AES do szyfrowania (np. haseł użytkowników w bazie danych)
			\item	routes - tak zwany router aplikacj Play. Jest to odwzorowanie zapytań HTML (GET, POST...) 
				na metody kontrolerów.		
		\end{itemize}
	\item	project - ustawienia projektu, głównie zależności biblioteczne
		\begin{itemize}
			\item	Build.scala - dependencje dla technologii sbt, opartej na Ivy (Apache), domyślnie wykorzystywanej 
				przez Play! Framework
			\item	plugins.sbt - wtyczki sbt
		\end{itemize}
	\item	puplic - publiczne statyczne pliki:
		\begin{itemize}
			\item	images - obrazy
			\item	botstrap - biblioteki Twitter Bootstrap
			\item	javascripts - między innymi jTable i HighCharts
			\item	stylesheets - css
		\end{itemize}
	\item	test - testy jednostkowe i integracyjne
\end{itemize}

\section{Modele}

Pakiet ,,models'' jest pakietem, w który znajdują się modele danych, czyli encje w postaci klas Javy. Twórcy Play'a proponują skorzystanie z 
frameworka persystencji dołączonego do bibliotek Play'a - Ebean. Technologia relizuje połączenie z bazą danych i persystencję klas Javowych. 
Wykorzystuje sterowniki JDBC i realizuje mapowanie relacji encji na podstawie adnotacji JPA. Ponadto, encje modelu danych rozszerzają klasę 
\begin{verbatim}play.db.Model\end{verbatim}, która dostarcza sporo wygodnych funkcji na wyższym poziomie abstrakcji. Skorzystaliśmy z oferowanej 
pezez Play! Framework funkcjonalności możliwości definiowania publicznych pól klasy modelu. Play! symuluje na takich polach mechanizm ,,Properties'', 
co daje pewną wygodę, jednak nie każdemu musi pasować taka opcja. Można zwyczajnie uczynić te pola prywatymi i wygenerować dla nich gettery i settery. 
Przejście na taką konwencję jest szybkie i proste przy użyciu mechanizmu refaktoryzacji dowolnego IDE. Można to zrobić w każdym momencie, jednak 
należy się nad tym moważnie zastanowić. Przy takiej zmianie bowiem serwer Ebean będzie dokonywał automatycznego dociągania danych do klasy według 
napisanych przez nas getterów (a nie, tak jak wcześniej, poprzez użycie publicznego ,,property''). Z tego powodu może istnieć potrzeba odwoływania się 
do prywatnych atrybutów wewnątrz klasy poprzez gettery, a nie przez bezpośredni dostęp.

\subsection{Model danych}

Przedstawiamy wykres relacji encji naszego systemu. \\

\begin{figure}[H]
\centering
\includegraphics[scale=0.6]{images/erd.jpg}
\caption{Diagram Relacji Encji}
\label{fig:erd}
\end{figure}

System zawiera następujące modele (widoczne na diagramie ER):
\begin{itemize}
	\item	\begin{verbatim}User\end{verbatim} Użytkownik naszej aplikacji. Encja zawiera na razie tylko login i hasło. Hasło jest szyfrowane 
		za pomocą automatycznego mechanizmu szyfrującego techonogii Ebean. Pogega ta na dodaniu adnotacji 
		\begin{verbatim}@Encrypted(dbEncryption=false)\end{verbatim} do pola, które ma być przechowywane w bazie danych w postaci 
		zaszyfrowanej. Atrybut dbEncryption wskazuje, czy szyfrowanie ma się odbywać po stronie systemu zarządzania bazą danych, czy po 
		stronie naszej aplikacji. Wybraliśmy szyfrowanie po stronie aplikacje z dwóch względów:
		\begin{itemize}
			\item	Szyfrowanie po stronie systemu zarządzania bazą danych wymaga zainstalowania tam specjalnych funkcji i modułów
			\item	Wolimy, aby odbywało się to po stronie aplikacji. Dane będą od razu wędrowały przez sieć w postaci zaszyfrowanej 
				a my skorzystamy z klucza naszej aplikacji
		\end{itemize}
		Kluczem głównym jest login użytkownika.\\
		Encja użytkownika jest połączona z następującymi encjami:
		\begin{itemize}
			\item	Project - lista projektów stworzonych przez użytkownika
			\item	Contributor - listę encji reprezentujących uczestnictwa tego użytkownika w projektach.
		\end{itemize}

	\item	\begin{verbatim}Project\end{verbatim} Projekt informatyczny. Zawiera nazwę i opis oraz liczbowy identyfikator - klucz główny. 
		Nazwa projektu musi być unikalna dla danego użytkownika (właściciela). Projekt posiada następujące połączenia z innymi encjami:
		\begin{itemize}
			\item	User - jednego właściciela
			\item	Contributor - listę pracowników
			\item	MileStone - listę kamieni milowych
			\item	Task - listę zadań
		\end{itemize}

	\item	\begin{verbatim}MileStone\end{verbatim} Kamień milowy, jednostka organizacyjna projektu informatycznego. Encja przechowuje datę stworzenia, 
		termin realizacji, nazwę i opis. Kamień milowy posiada następujące połączenia z innymi encjami:
		\begin{itemize}
			\item	Project - projekt, którego jest częścią
			\item	Task - listę zadań przypisanych do tego kamienia milowego
		\end{itemize}

	\item	\begin{verbatim}Task\end{verbatim} Zadanie. Posiada długą listę atrybutów:
		\begin{itemize}
			\item	id - liczbowy klucz główny
			\item	taskNumber - numer porządkowy zadania w obrębie projektu
			\item	name - skrótowy opis, tytuł
			\item	description - dokładny opis
			\item	priority - priorytet zadania. Wartością jest enum (models.Priority) o następujących wartościach:
			\begin{itemize}
				\item	HIGHEST
				\item	HIGH
				\item	MEDIUM
				\item	LOW
				\item	LOWEST
			\end{itemize}
			\item	taskKind - rodzaj zadania. Wartością jest enum (models.TaskKind) o następujących wartościach:
			\begin{itemize}
				\item	TASK
				\item	DEFECT
				\item	ENHANCEMENT
				\item	DOCUMENTATION
				\item	CONFIGURATION
				\item	QUESTION
			\end{itemize}
			\item	creationDate - data stworzenia zadania
			\item	dueDate - termin realizacji. Jeśli nie zostanie wprost podany, to jest dziedziczony po terminie realizacji 
				kamienia milowego, do którego należy zadanie (o ile do jakiegoś należy).
			\item	taskStatus - status zadanie. Wartością jest enum (models.TaskStatus), który na razie przewiduje takie wartości:
			\begin{itemize}
				\item	OPENED
				\item	CLOSED
			\end{itemize}
		\end{itemize}	
 		Zadanie posiada także następujące połączenia z innymi encjami:
		\begin{itemize}
			\item	User - dwa pola odnoszą się do encji User: assignee oraz creator. Czyli odpowiednie: osoba zajmująca się aktualnie 
				tym zadaniem oraz osoba, ktora je stworzyła.
			\item	MileStone - kamień milowy, do którego zadanie jest przypisane. To pole dopuszcza wartość null.
			\item	Project - projekt, którego częścią jest zadania. To pole nie może być nullem.
			\item	HistoryEvent - lista zdarzeń związanych z zadaniem (komentarze, zmiany statusu itp.)
			\item	WorkReport - raporty z pracy nad zadaniem (głównie raportowanie godizn pracy)
		\end{itemize}
	\item	\begin{verbatim}Contributor\end{verbatim} Pracownik projektu. W języku bazodanowym jest to tabela łącznikowa, łączące encje użytkowników 
		z necjami projektu. Ma zatem znaczenie "Użytkownik user jest pracownikiem projektu project". Encja posiada liczbowy klucz główny oraz 
		dodatkowy atrybut: \begin{verbatim}role\end{verbatim} o wartości enum'a Role (models.Role), który dopuszcza następujące wartości:
		\begin{itemize}
			\item	ADMIN - uprawnienia administratora projektu. Opisaliśmy je szczegółowo w wymaganiach oraz w dokumentacji modułu 
				bezpieczeństwa aplikacji.
			\item	CONTRIBUTOR - jest to zwykły pracownik projektu.
			\item	DELTED - oznacza, że użytkownik był kiedyś współpracownikiem w projekcie, ale już nim nie jest. Wolimy przechowywać 
				to w tej postaci, niż usuwać wpis z bazy danych, poniważ informacje z nim związane mogą być potrzebne do 
				analiz i statystyk Poza tym, można w ten sposób odebrać komuś czasowo uczestnictwo w projekcie i potem łatwo 
				przywrócić tą osobę do udziału w projekcie.
		\end{itemize}
		Encja posiada także powiązania z innym encjami:
		\begin{itemize}
			\item	User - użytkownik, który jest współpracownikiem opisywanym przez encję
			\item	Project - projekt, którego dotyczy współpraca
		\end{itemize}
	\item	\begin{verbatim}HistoryEvent\end{verbatim} Encja przedstawiająca jakieś zdarzenie związane z zadaniem. Może to być komentarz do zadania 
		albo zmiana statusu na otwarte lub zamknięte. Po ewentualnej rozbudowie możliwych atrybutów zadania, będą mogły tu być przechowywane 
		przeróżne zdarzenia. Encja posiada takie atrybuty:
		\begin{itemize}
			\item	id - klucz główny
			\item	comment - treść ewentualnego komentarza (niewymagana)
			\item	changeTo - pole type TaskStatus. Opcjonlne. Oznacza zmianę statusu zadania.
			\item	date - data, kiedy miało miejsce zdarzenie
		\end{itemize}
		Posiada także powiązania z takimi encjami:
		\begin{itemize}
			\item	User - użytkownik, które dokonał akcji
			\item	Task - zadanie, którego dotyczyła akcja
		\end{itemize}

	\item	\begin{verbatim}WorkReport\end{verbatim} Raport z pracy. Na razie jest to tylko liczba godzin spędzonych nad zadaniem. Atrybuty to 
		identyfikator, data i liczba godzin. Dodatkowo istnieją odniesienia do innych encji:
		\begin{itemize}
			\item	Task - zadanie, nad którym pracował użytkownik zgłaszający raport
			\item	Contributor - pracownik projektu, który pracował nad zadaniem
		\end{itemize}
\end{itemize}

\subsection{Metody modeli}
Każdy model posiada statyczne publiczne pole ,,find'', które słóży do formułowania zapytać zwracających obiekty klasy danej encji.\\
Każdy model posiada standardowy zestaw funkcji:
\begin{itemize}
	\item	all - statyczna metod, zwracająca wszystkie wpisy tego typu
	\item	create - statyczna metoda, zapisująca w bazie obiekt podany jako parametr
	\item	remove - statyczna metoda, usuwa obiekt o podanym id
	\item	findById - statyczna metoda, odszukuje obiekt po identyfikatorze
\end{itemize}
Część modeli posiada także funkcje ,,toJsonObject'' oraz ,,simpleJson'', które są nam potrzebna na użytek komunikacji z graficznym interfejsem 
pisanym w jQuery. \\
Niektóre modele mają także pewne funkcje o wyższym poziomie abstrakcji, przerzucające część logiki biznesowej na modele:

\begin{verbatim}MileStone\end{verbatim}
\begin{itemize}
	\item	tasksCount(TaskStatus status) -- liczba zadań w tym kamieniu milowym, o podanym statusie
	\item	openedTasksCount() -- liczba otwartych zadań
	\item	closedTasksCount() -- liczba zamkniętych zadań
\end{itemize}

\begin{verbatim}Project\end{verbatim}
\begin{itemize}
	\item	activeContributors() -- aktywni pracownicy, czyli o statusie ADMIN lub CONTRIBUTOR
	\item	contributorByUser(User user) -- encja pracownika tego projektu dla podanego użytkownika
	\item	allTasks(String mileStoneId, String statusId,
String contributorId, String priorityId, String taskTypeId,
String creatorId, String sorting) -- metoda zwracająca zadania posortowane i przefiltrowane według podanych wzorców.
	\item	findByName(String name, User user) -- statyczna metoda zwracająca projekt o podanej nazwia dla podanego użytkownika. Przydaje się, 
		aby sprawdzać, czy dany użytkownik nie ma już projektu o takiej nazwie.
\end{itemize}

\begin{verbatim}Task\end{verbatim}
\begin{itemize}
	\item	findByTaskNumber(long projectId, long taskNumber) -- statyczna metoda wyszukująca po numerze porządkowym
	\item	prepereTaskNumber() -- przydziala numer porządkowy, sprawdzając numer ostatniego zadania w projekcie
\end{itemize}

\begin{verbatim}User\end{verbatim}
\begin{itemize}
	\item	authenticate(String login, String password) -- statyczna metoda, sprawdzająca poprawność podanych danych do uwierzytelniania
	\item	contributedProjects() -- projekty, w których pracuje użytkownik
	\item	contributesAt(Project project) -- sprawdza, czy użytkownik jest pracownikiem podanego projektu
	\item	contributions(Project project) -- zwraca listę encji, reprezentujących udział w danym projekcie
	\item	uniqueContribution(Project project) - zwraca to co wyżej, ale unikalny wynik (w bazie możemy mieć tylko jeden obiekt dla danego 
		użytkownika i danego projektu - prara unikalna).
\end{itemize}

\section{Kontrolery - logika biznesowa}

Pakiet ,,controllers’’ to moduł odpowiedzialny za logikę biznesową i interakcję z użytkownikiem poprzez zapytania i odpowiedzi HTTP.
Jest to typowy element wzorca ,,Model-View-Controller’’ z dostępem do warstwy danych (pakiet models)
oraz sterujący interakcją z widokiem (pakiet views).
Każdy kontroller musi rozszerzać klasę play.mvc.Controller a wynik zwracany przez mateody
kontrolerów to play.mvc.Result.
Metody naszych kontrolerów są na razie statyczne (tak domyślnie jest to w Play’u), ale można
to bardzo łatwo zmienić, angażując dowolny mechanizm Dependency Injection.
W dalszej fazie projektu warto zatem zastosować jakiś kontener IoC, najprędzej byłby to Spring.
Klasy kontrolerów bądź ich metoda są oznaczone zestawem adnotacji:
\begin{itemize}
    \item    @Security.Authenticated(Secured.class) - sprawdza, czy istnieje kontekst logowania,
czyli czy w sesji użytkownika jest zapisany jego login. Jeśli nie, użytkownik nie ma dostępu
do metoda kontrolera i jest przekierowany do do strony zdefiniowanej w konfiguracji
mechanizmu Security. Adnotacja może dotyczyć klasy albo metody.
\item    @Restrict(@Group(,,ROLE")) - podobnie, jeśli użytkownik nie posiada opisanej
    roli (ADMIN lub CONTRIBUTOR), nie zostanie dopuszczony do tej akcji.
    Adnotacja może dotyczyć klasy albo metody.
\end{itemize}

\subsection{Kontroler Application}
Jest to podstawowy kontroler, które nie obejmuje logiki biznesowej, ale jest swego rodzaju bramą
do systemu. Posiada metody logowania zakładanie kont itp. Cały kontroler jest oznaczony
adnotacją @Security.Authenticated(Secured.class), ponieważ trzeba być zalogowanym,
aby tu się znaleźć. Jednak większość metod nie wymaga żadnej roli w projekcie,
ponieważ są to prywatne widoki i metody użytkownika. Metody te są następujące:
\begin{itemize}
    \item    public static Result index() -- przekierowuje do głównej strony użytkownika.
        Jest to strona z jego projektami. Jeśli nie jest zalogowany, to mechanizm
        Security przeniesie go do strony logowania. Zatem zawartość strony
        ,,index’’ zależy od tego, czy użytkownik jest zalogowany.
    \item    public static Result login() -- przekierowuje do strony logowania, czyszcząc
        wcześniej sesję użytkownika (w tym kontekst logowania).
    \item    public static Result authenticate() -- metoda uwierzytelniania. Odczytuje
        formularz logowania (filledLoginForm). Sprawdza, czy nie ma błędów
        (np. nie wszystkie wymagane pola zostały podane). Sprawdza następnie
        poprawność podanych danych (metodą User.authenticate). Jeśli formularz
        miał błędy lub dane były niepoprawne, wykonuje metodę reject na obiekcie
        filledLoginForm i podaje filledLoginForm jako parametr renderowania strony
        logowania. Dzięki temu widok wyświetli informację podaną jako parametr
        metody reject. Jeśli uwierzytelnianie powiodło się, zapisujemy kontekst
        logowania w sesji (wywołanie: session("user", login.login)) i przekierowujemy
        użytkownika do strony z jego projektami.
    \item    public static Result registerWindow() -- wyświetla okno do rejestracji.
    \item    public static Result register() -- Metoda wywoływana po zatwierdzeniu formularza
        rejestracji w przeglądarce. Metoda wiąże argumenty HTTP POST do formularza
        i obiektu Register (lokalna, pomocnicza klasa wewnętrzna). Sprawdza, czy
        formularz ma błędy. Błędy będą sprawdzone przez metodę validate klasy
        Register (sprawdza, czy istnieje już użytkownik o takim loginie oraz czy
        rubryki ,,hasło’’ oraz ,,potwierdź hasło’’ się zgadzają). Jeśli formularz
        ma błędy, przekazujemy ten formularz do renderowanego widoku, aby
        wyświetlić użytkownikowi, jakie błędy popełnił podczas uzupełniania formularza.
        Jeśli błedów nie było, zapisujemy nowego użytkownika w bazie danych,
        zapisujemy jego kontekst logowania w sesji oraz przekierowujemy go do
        strony z jego prjektami.
    \item    public static Result logout() -- czyścimy sesję użytkownika i przekierowujemy
        go do strony z logowaniem.
\end{itemize}

\subsection{Kontroler Projects}
Kontroler głównego widoku użytkownika oraz operacji na jego projektach - dodawanie nowych
itp. Ma następujące metody:
\begin{itemize}
    \item    public static Result myProjects() -- zwraca projekty użytkownika. Osobno te
        stworzone przez niego i osobne te, w których tylko uczestniczy.
    \item    public static Result addProject() -- dodaje nowy projekt. Tworzy obiekt
        filledForm, czyli formularz projektu. Uzupełnie następnie login użytkownika
        w formularzu, ponieważ nie był on podany w formularzu (dzięki temu
        przetwarzanie formularza automatycznie zwiąże referencję do obiektu
        klasy User). Sprawdzamy następnie, czy formularz ma błędy a także, czy
        użytkonik nie ma już czasem projektu o tej nazwie. Jeśli coś jest nie tak,
        wykonujemy ,,reject’’ na formularzu, podając przyczynę i z powrotem
        renderujemy stronę, z której przyszło zapytanie. Jeśli wszystko było dobrze,
        zapisujemy w bazie nowy projekt, w flashu zapisujemy informację o idanej akcji
        i renderujemy stronę z projektami użytkownika.
    \item    public static Result projectMain(long id) -- przejście na stronę główną projektu
        o podanym identyfikatorze (id).
\end{itemize}
\subsection{Kontroler Contributors}
Ten kotroler działa już na konkretnym projekcie. Każda metoda przyjmuje identyfikator projektu
(long projectId). Wszystkie motedy zwracające Result są oznaczone adnotacjami @Restrict,
ale z podanymi różnymi rolami. Tutaj bowiem widać największą różnicę w uprawnieniach
członków projektu. Metoda dla wszystkich członków (rola CONTRIBUTOR) to:
\begin{itemize}
    \item    public static Result contributors(long projectId) - renderowanie strony z
        członkami projektu.
    \item    public static Result list(long projectId) -- wylistowanie członków projektu. Dane są
        zwracane w formacie JSON na potrzeby biblioteki jTable.
\end{itemize}
Metoda dla użytkowników z rolą ,,ADMIN’’ to:
\begin{itemize}
    \item    public static Result create(long projectId) -- tworzy nowy projekt. Wiąże formularz
        z zapytania HTTP (filledForm). Sprawdza różne błędy, m.in. czy podany login
        użytkownika występuje w systemi. Jeśli pojawiły się jakieś błędy zwracamy błąd
        w formacie JSON (np. getJsonResultERROR("No such user in the system.")).
        Podobnie sprawdzamy, czy podany użytkownik nie uczestniczy już w projekcie.
        Jeśli wszystko jest dobrze, dodajemy użytkownika do projektu, zapisując w bazie
        danych obiekt klasy Contributor, opisujący uczestnictwo w projekcie. Obiekt ma
        automatycznie związaną z argumentów POST HTTP rolę użytkoniwka.
    \item    public static Result update(long projectId) -- aktualizacja danych o członku
        projektu (np. jego rola). Nie można tu zmienić roli administratora dla właściciela
        projektu (zwracamy wówczas JSON error). Obiekt Contributor jest wiązany z
        argumentów metody POST i wystarczy tylko wykonać ,,update’’ na tym modelu.
    \item    public static Result delete(long projectId) -- usuwanie użytkownika z projektu.
        Ponownie, nie można usunąć właściciela projektu. Nie usuwamy z bazy obiektów
        Contributor, ale ustawiamy ich stan na DELETED. Dzięki temu przechowujemy
        historię i nie tracimy potencjalnie potrzebnych danych.
\end{itemize}
Kontroler posiada także kilka pomocniczych metod do obsługi i konstrukcji odpowiedzi w formie
JSON.
\subsection{Kontroler MileStones}
Ten kontroler odpowiada za operacje na kamieniach milowych. Jest oznaczony dwoma adnotacjami:
\begin{itemize}
\item    @Security.Authenticated(Secured.class) -- użytkownik musi być zalogowany.
\item    @Restrict(@Group("CONTRIBUTOR")) -- oznacza to, że do każdej akcji tego
    kontrolera wymagana i wystarczająca jest rola ,,członka’’ projektu. Żadne metody
    kontrolera MileStones nie posiadają dodatkowych adnotacji odpowiedzialnych
    za bezpieczeństwo aplikacji.
\end{itemize}
Ten kontroler także obsługuje zapytania pochodzące z interfejsu graficznego pisanego
w bibliotece jTable, dlatego również będzie trochę operował formatem JSON oraz również
zawiera metody pomocnicze do obsługi tego formatu. Metoda kontrolera są następujące:
\begin{itemize}
    \item    public static Result list(long projectId) -- zwraca listę kamieni milowych dla
        danego projektu (projectId) w formacie JSON.
    \item    public static Result create(long projectId) -- pobiera obiekt MileStone z
formularza, nie sprawdzając błędów, ponieważ nie ma tu żadnych
potencjalnych ostrzeżeń czy błędów. Przypisujemy kamieniowi milowemu
projekt na podstawie projectId oraz zapisujemy datę utworzenia. Data
realizacji, jeśli była podana, sama została związana z formularza. Zapisujemy
kamień milowy w bazie i zwracamy komunikat o powodzeniu akcji.
\item    public static Result update(long projectId) -- wiąże obiekt klasy MileStone z
    argumentów metody POST HTTP. Aktualizuje jego stan w bazie i zwraca
    komunikat o udanej akcji w formacie JSON.
\item    public static Result delete(long projectId) -- usuwa podany kamień milowy,
sprawdzając, czy należy on do projektu o identyfikatorze projectId. Nie usuwamy
obiektu mileStone, jeśli przynależą do niego inne obiekty w bazie (np. zadania).
\item    public static Result mileStoneSite(long projectId, long mileStoneId) -- renderuje
    stronę szczegółową kamienia milowego o identyfikatorze mileStoneId,
sprawdzając, czy należy on do podanego projektu (projectId).
\end{itemize}
\subsection{Kontroler Tasks}
Ten kontroler odpowiada za akcje dokonywane na zadaniach. Tabelka z zadaniami również
została napisana w bibliotece jTable, także również ten kontroler posługuje się odpowiedziami
w formacie JSON. Posiada następujące metody:
\begin{itemize}
    \item    public static Result tasks(long projectId) -- renderuje stronę z zadaniemi z
        podanego projektu.
    \item    public static Result list(long projectId) -- zwraca listę zadań dla
        danego projektu (projectId) w formacie JSON. Dodatkowo zadania są
        posortowane i przefiltrowane według paramterów podanych w zapytaniu
        POST HTTP. Parametr ,,jtSorting’’ jest napisanem, określającym, po czym
        chcemy sortować i jak (np. ,,status ASC”). Parametry do filtrowania są
        intuicyjne i nie wymagają objaśnienia.
    \item    public static Result create(long projectId) -- pobiera obiekt Task z
formularza, sprawdzając, czy nie ma błędów. Przypisujemy zadaniu
projekt na podstawie projectId, zapisujemy datę utworzenia, użytkownika
tworzącego a status automatycznie ustawiamy na OPENED. Dodatkowo,
metoda prepereTaskNumber() przypisuje numer porządkowy zadania
w ramach projektu. Data  realizacji, jeśli była podana, sama została związana
z formularza. Jeśli nie, to jako datę realizacji ustawiamy datę realizacji
powiązanego obiektu MileStone (o ile nie jest null’em). Zapisujemy
zadanie w bazie i zwracamy komunikat o powodzeniu akcji.
\item    public static Result update(long projectId) -- wiąże obiekt klasy Task z
    argumentów metody POST HTTP. Aktualizuje jego stan w bazie i zwraca
    komunikat o udanej akcji w formacie JSON.
\item    public static Result delete(long projectId) -- usuwa podane zadanie.
\item    public static Result mileStonesOptions(long projectId) -- zwraca listę
    kamieni milowych w tym projekcie. Metoda jest potrzebna graficznemu
    interfejsowi, aby wybrać kamień milowy z listy. Na początku listy
    umieszczamy nodeUnassigned, który jest pustą wartością. Jeśli użytkownik
    wybierze tą opcję z listy, kamień milowy dla danego zadania będzie null’em.
\item    public static Result contributorsOptions(long projectId) -- analogicznie: zwraca
    listę członków projektu. Na początku listy umieszczamy nodeUnassigned,
który jest pustą wartością. Jeśli użytkownik wybierze tą opcję z listy,
kamień milowy dla danego zadania będzie null’em.
\item    public static Result taskSite(long projectId, long taskId) -- renderuje
    stronę szczegółową zadania. Liczba taskId jest numerem porządkowym
    zadania w projekcie, a nie jego identyfikatorem.
\item    public static Result closeTask(long projectId, long taskId) -- Zamyka podane
    zadanie. Liczba taskId jest numerem porządkowym zadania w projekcie,
a nie jego identyfikatorem. W bazie danych zapisujemy akcję informującą,
że zaszło takie zdarzenie (HistoryEvent) oraz zmieniamy status zadania na
CLOSED.
\item    public static Result reopenTask(long projectId, long taskId) -- Akcje zupełnie
    analogiczna do powyższej (closeTask), tyle że tutaj zmieniamy status
    na OPENED.
\item    public static Result commentTask(long projectId, long taskId) -- Jest to podona
    akcja do ,,closeTask’’ i ,,reopenTask’’, ponieważ tutaj także tworzymy obiekt
    HistoryEvent i zapisujemy go w bazie danych, ale ustawiamy w nim
jednocześnie komentarz a status zostaje null’em.
\item    public static Result listWorkReports(long projectId, long taskId) -- zwraca listę
    raportów pracy(WorkReport), czyli zgłoszonych godzin pracy. W przeglądarce
    są one wyświetlane w tabelce jTable, więc i tu lista godzinek będzie przesłana
    JSON-em. Zwrócone obiekty dotyczą zadania o numerze prządkowym (nie
    ID) taskId w projekcie o identyfikatorze projectId.
\item    public static Result reportHours(long projectId, long taskId) -- zgłaszanie
    godzin pracy spędzonych nad zadaniem o numerze prządkowym (nie
    ID) taskId w projekcie o identyfikatorze projectId. Obiekt klasy WorkReport
    związujemy z formularza. Sprawdzamy, czy nie ma błędów i zapisujemy
    obiekt w bazie danych, przypisując mu wcześniej atrybuty: datę, powiązane
    zadanie oraz członka projektu.
\end{itemize}




\section{Bezpieczeństwo aplikacji - pakiet security}

Pakiet ,,security'' jest modułem aplikacji odpowiedzialnym za ochronę przed nieupoważnionym dostępem. Klasy tego modułu są implementacjami interfejsów dwóch mechanizmów ułatwiających automatyczne chronienie akcji kontrolerów w wypadku, gdy użytkownik nie ma do nich praw. Te dwa mechanizmy to:
\begin{itemize}
	\item	Play Security - wbudowany mechanizm bezpieczeństwa framework'a Play! Zawiera bardzo przyjazny mechanizm autentykacji. Wymaga zaimplementowania klasy Security.Authenticator i jej dwóch metod:
	\begin{itemize}
		\item	getUsername - zwraca nazwę zalogowanego użytkownik. Jeśli zwróci null, to użytkownik nie jest zalogowany, co z kolei spowoduje przekierowanie do kolejnej metody: 
		\item	onUnauthorized - tutaj możemy zdefiniować akcję do wykonania w razie niepowodzenia autentykacji. Zwykle podaje się tu stronę z logowaniem. W efekcie, mechanizm zadziała po dodaniu adnotacji ,,@Security.Authenticated(MySecured.class)'' na klasie kontrolera bądź na dowolnej jego metodzie.
	\end{itemize}	
	\item	Play Deadbolt (be.objectify.deadbolt) - zewnętrzny moduł napisany na potrzeby Play! framework. Zawiera poniekąd funkcjonalności modułu Play Security, ale jest wolniejszy, ponieważ sprawdza więcej warunków i często musi się odwoływać do bazy danych. Poza tym, w naszym przypadku Play Security i Deadbolt wykorzystują inne podmioty uwierzytelniania. Dlatego Deadbolt jest przez nas używany w sytuacjach, które tego wymagają i w których Play Security już nie wystarcza. Deadbolt dostarcza podobną możliwość filtracji uprawnień ale już na podstawie ról użytkownika. Może to na przykład być administrator lub zwykły użytkownik aplikacji. Rola musi być konkretną klasą - enumem implementującym be.objectify.deadbolt.core.models.Role. Natomiast encja, do której przynależy rola implementuje interfejs Subject. Podobnie jak w module Play Security, wystarczy następnie tylko dodać adnotacje do kontrolerów lub ich metod: \begin{verbatim}@Restrict(@Group("ADMIN"))\end{verbatim}
\end{itemize}

\subsection{Mechanizm uwierzytelniania - Secured}

Nasz mechanizm uwierzytelniania korzysta z modułu Play Security. Jest to klasa security.Secured, implementująca wspomniany wyżej interfejs Security.Authenticator. Nasza metoda \begin{verbatim}getUsername(Context ctx)\end{verbatim} pobiera nazwę użytkownika z sesji - z plików cookies. Jeśli nazwa użytkownika nie została tam zapisana, to metoda zwróci null - uwierzytelnianie się nie powiedzie. Nazwa użytkownika jest zapisywana w sesji użytkownika w metodzie authenticate() kontrolera cotrollers.Application. Przetrzymywanie nazwy użytkownika w sesji jest bezpieczne - pliki cookies są szyfrowane i podpisywane, więc złośliwy użytkownik nie będzie mógł podmienić ich treści. W razie niepowodzenia autentykacji (zwrócenie null), nasza metoda onUnauthorized(Context ctx) przekieruje użytkownika do strony startowej - strony logowania.

\subsection{Mechanizm chronienia zasobów przed nieupoważnionymi użytkownikami - MainDeadboltHandler}

Jest to mechanizm wykorzystujący modułDeadbolt. Nie wystarcza nam jedynie sprawdzanie, czy użytkownik się zalogował w naszej aplikacji. Chcemy też, aby:
\begin{itemize}
	\item	Użytkownik nie miał dostępu do zasobów projektu, do którego nie został zaproszony - musi mieć uprawnienie pracownika projektu, aby cokolwiek zrobić
	\item	W projekcie był podział na role: administratorzy i pracownicy. Niektóre akcje wymagają uprawnień administratora - a inne tylko pracownika. Dodatkowo, w przyjętej przez nas logice rola administratora rozszerza rolę pracownika - tak więc administrator jest także pracownikiem.
\end{itemize}
Do poprawnego skonfigurowania mechanizmu konieczne było napisanie kilku klas i implementacja pewnych interfejsów przez kilka innych klas:

\begin{itemize}
	\item	security.MainDeadboltHandler - implementacja interfejsu DeadboltHandler. Jest to rdzeń całego mechanizmu. Zawiera on akcję onAuthFailure: podobną jak w mechanizmie Play Security. Jest to akcja, którą wykonamy, jeśli użytkownik nie ma praw do akcji, której rząda. Metoda zwróci informację błędu w formacie json. Format taki jest wymagany przez nasz webowy interfejs graficzny - tabelka oparta na jQuery wymaga takiego formatu komunikatu. Przyda się to na przykład wtedy, gdy zwykły użytkownik spróbuje zrobić coś, co może robić tylko administrator. Ten sam json'owy format wiadomości zobaczy użytkownik w przeglądarce, jeśli nie miał określonych praw w projekcie. Uznaliśmy, że na razie nie musimy wyświetlać takiemu użytkownikowi strony w ładniejszym formacie. Kolejno, MainDeadboltHandler zawiera metodę getSubject, która (na podstawie ścieżki http request) i zawartości plików cookies użytkownika, określa jaki użytkownik i do jakiego projektu próbuje się dostać. Zwróci następnie ,,Subject'', czyli pobierze z bazy danych encję opisującą udział danego użytkownika w danym projekcie - czyli obiekt klasy Contributor. Jeśli użytkownik w tym projekcie nie uczestniczy, wówczas metoda zwróci null
	\item	models.Contributor - encja naszego modelu danych. Jest tabelą łącznikową użytkownika i projektu - opisuje przynależność jakiegoś użytkownika do jakiegoś projektu. Implementuje interfejs Subject. Oznacza to, że jest podmiotem dla akcji wykonywanych przez mechanizm Deadbolt. Obiekt tej klasy jest zwracany przez metodę jetSubject klasy MainDeadboltHandle. Posiada metodę getRoles(), które zwraca listę ról w projekcie. Jeśli rolą użytkownika jest CONTRIBUTOR - zwróci taką wartość w jednoelementowej liście. Jeśli ADMIN - zwróci listę złożoną z obu tych ról. Tak jak wspomnieliśmy wcześniej - ADMIN rozszerza CONTRIBUTOR.
	\item	models.Role - enum o dwóch wartościach: 
	\begin{itemize}
		\item	ADMIN
		\item	CONTRIBUTOR
	\end{itemize}
	Implementuje interfejs be.objectify.deadbolt.core.models.Role i jego metodę \begin{verbatim}getName()\end{verbatim} Wartość zwracana przez tą metodę jest podstawą dla filtrów \begin{verbatim}@Restrict\end{verbatim}, których możemy używać w kontrolerach:
	\item	controllers.*  - w tym pakiecie wykorzystujemy już to wszystko, co poprzednio zaimplementowaliśmy. Możemy dodawać na przykład adnotacje \begin{verbatim}@Restrict\end{verbatim} dla klasy kontrolera bądź dla jego metod. Przykład wykorzystania: \begin{verbatim}@Restrict(@Group("CONTRIBUTOR")) \end{verbatim}
\end{itemize}
\section{Interfejs graficzny}

\subsection{Projekt interfejsu graficznego}
Staraliśmy się zaprojektować wygodny i intuicyjny interfejs graficzny. Użytkownik powinien od początku widzieć jak 
najbardziej ogólne rzeczy i szybko przechodzić do szczegółów swojego projektu, mając jednoczesny pogląd na jak 
największą ilość elementów. Zaplanowaliśmy następującą grupę widoków:
\begin{itemize}
	\item	Widok początkowy - logowanie, rejestracja i dodatkowa zakładka z informacjami o produkcie. Wchodząc na stronę, 
		użytkownik domyślnie zobaczy zakładkę z logowaniem, ponieważ najprawdopodobniej to będzie go interesowało.
	\item	Strona główna użytkownika - jest to strona najogólniejsza. Użytkownik zobaczy tu wszystko swoje projekty. Będzie miał 
		także linka do edycji swojego profilu i wylogowywanie. Także tutaj znajdzie formularz zakładanie nowego projektu.
	\item	Strona projektu - Tutaj użytkownik przejdzie po kliknięci w link z tabelki ze swoimi projektami. Na górze będzie miał 
		zakładki z :
	\begin{itemize}
		\item	Zadaniami
		\item	Kamieniami milowymi
		\item	Współpracownikami
		\item	Wykresami pracy
	\end{itemize}
		Domyślnie załaduje się strona z zadaniami, ponieważ to ona jest najważniejsza. Zadanie, kamienie milowe i współpracownicy 
		będą prezentowane w interaktywnych tabelkach. W tabelach będą linki do stron szczegółowych odpowiednio: zadań, 
		kamieni milowych czy też współpracowników.
	\item	Strony szczegółow dla pojedynczych bytów:
	\begin{itemize}
		\item	Zadanie - Będą tu dostępne wszystkie atrybuty zadanie, wszystko w przejrzystej formie. W tabelce z zadaniami te
			dane będą mogły być prezentowane tylko skrótowo i pobieżnie. Tu natomiast będzie ładniej, dokładniej i bardziej 
			przejrzyście. Będzie także formularz dodawania komentarza. Pojawi się również historia: doytychczasowe zmiany 
			(otwieranie i zamykanie tego zadania) oraz komentarze.
		\item	Kamienień milowy - tutaj sytuacja jest bardzo podobna. Również będą zaprezentowane różne dane oraz (być może) 
			dodawanie komentarzy.
		\item	Współpracownik - Będą tu informacje o pracowniku projektu a także dane o jego pracy - liczy i wykresy.
	\end{itemize}
\end{itemize}

Prezentujemy wykres opisanego interfejsu graficznego. Uwzględniliśmy w nim generyczne widoki, przejścia między widokami oraz różne typy 
komponentów na stronie html (opisane w legendzie po lewej stronie). \\

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{images/ui_chart.png}
\caption{Struktura interfejsu graficznego}
\label{fig:ui_chart}
\end{figure}


\subsection{Technologie i biblioteki}
Implementacja webowego interfejsu graficznego wykorzystuje kilka technologii i bibliotek. Technologie są związane z 
wykorzystaną technologią webową, biblioteki natomiast są bibliotekami opartymi na JavaScript i jQuery. Technologia 
powiązana z budowaniem widoków to:
\begin{itemize}
	\item	Play! Framework Template Engine - jest to typowy mechanizm widoków w technologiach webowych MVC. 
		Widok (plik .scala.html) jest kompilowany do klasy w języku Scala. Okeśla się, jakie argumenty potrzebuje 
		dany widok do stworzenia treści strony i takie argumenty trzeba mu przekazać w statyczne metodzie render(), 
		którą wywołujemy w kontrolerach aplikacji webowej. Możliwe jest ponadto konstruowania widoku wewnątrz innego 
		widoku, dzięki czemu można stworzyć drzewkową strukturę generycznych widoków. Dalej opiszemy strukturę zależności 
		widoków w naszej aplikacji. \\
		Play! Framework Template Engine daje udostępnia zastaw tagów w języku Scala: instrukcja warunkowe, pętle itd. Mamy 
		także w zasadzie dostęp do wszystkich źródeł aplikacji a taże załączonych bibliotek, ale nie należy tego nadużywać 
		i przenosić logiki biznesowej do widoków.
\end{itemize}

Wykorzystamy również szereg bibliotek pomocniczych
\begin{itemize}
	\item	Twitter Bootstrap - bardzo popularny zestaw komponentów CSS i JavaScript. Przy minimum konfiguracji i pisania własnych 
		klas i stylów osiągnęliśmy szybko nowoczesny wygląd. W tej fazie projektu nie zamierzamy poświęcać zbyt dużo czasu 
		na wygląd aplikacji, jednak chcemy, aby strony naszego serwisu od razu przyzwoicie się prezentowały. Dodatkowo, wykorzystanie 
		Bootstrap'a da bardzo dużo możliwości w przyszłości, aby dostosować wygląd strony i rozbudować szatę graficznę. Być może, kiedyś 
		uda nam się znaleźć osobę, która poświęci więcej czasu na dopracowanie stylów CSS i zaprojektuje bardzo efektowny interfejs.
	\item	jTable - opisywaliśmy już wcześniej ten komponent. Biblioteka jest oparta na jQuery. W ramach naszych widoków musimy tylko 
		wstawić element <div>, a następnie umieścić w nim zainicjalizowanę tabelę. Tabelka wymaga podania pewnych atrybutów:
		\begin{itemize}
			\item	Linki, do któych będą przesyłane akcje: list, create, updated, delete. Będą to linki powiązane z konkretnymi 
				metodami naszych kontrolerów. Widzimy przy okazji, że tabele jTable obsługują pełny zestaw operacji CRUD 
				na przechowywanych elementach.
			\item	Kolumny tabeli: najlepiej nazwać je identycznie z nazwami pól odpowiadające klasy w modelu danych w aplikacji 
				webowej. Dzięki temu, przy akcjach tworzenia, edycji oraz usuwania Play! automatyczni powiąże dane z formularza 
				przesłanego przez jTable i stowrzy obiekt klasy z modelu danych. Dla kolumny tabeli możemy dodatkowo ustawić 
				pewne atrybuty, takie jak
				\begin{itemize}
					\item	displayValue - możemy tu manipulować wartością wyświetlaną w tabeli. Opcja jest bardzo przedatna 
						w tabeli z zadaniami, gdzie chcemy prezentować nie tylko czysty tekst, ale także różne 
						elementy graficzne, np. ikonki dla różnych rodzajów zadań czy różne kolory dla różnych priorytetów 
						zadań.
					\item	create, update - domyślnie te wartości są ustawione na true, ale zmianiając te pola na false, 
						sprawimy, że nie będzie można ich ustawić w formularzu - odpowiednio dodawania lub edcji.
					\item	list - także domyślnie true. Czasem jednak nie chcemy, aby wartość była wyświetlana w tabeli.
					\item	options - podajemy tu listę, słownik lub link, z którego w formacie JSON pobierzemy opcje w podobnym 
						formacie. Spośród tych opcji będziemy wybierać wartość pola i nie będziemy musieli wpisywać go ręcznie.
					\item	type - może być to na przykład 'date'. Dzięki temu datę w formularzu będziemy wybierać z kalendarzyka.
				\end{itemize}
			\item	Dodatkowo możemy ustawić pewne atrybuty całej tabeli, takie jak: możliwość sortowanie, domyślne sortowanie itp.
		\end{itemize}
		Wymiana danych z serwerem odbywa się za pośrednictwem formularzy i metody POST html a także za pośrednictwem JSON'a. W formacie JSON 
		przede wszystkim zwracamy dane z serwera do AJAX'owych zapytań tabeli jTable. Dla dokładniejszego poglądu przedstawiamy przykładową
		tabelę z naszego projektu, tabelę z kamieniami milowymi. Zawiera ona większość wymienionych weżej elementów. Wysztstko jest 
		wkomponowane w widok Play! Framework Template Engine: \\
		% TODO: lstlistings instead of verbatim - I'll do it
		
		
		\begin{verbatim}
@projectMain("mileStones", project, scripts = jtableScript) {
<div id="MilestonesTableContainer"></div>
}

@jtableScript = {
<script type="text/javascript">
        $(document).ready(function () {
            $('#MilestonesTableContainer').jtable({
                title: 'Mile Stones',
                actions: {
                    listAction: '@routes.MileStones.list(project.id)',
                    createAction: '@routes.MileStones.create(project.id)',
                    updateAction: '@routes.MileStones.update(project.id)',
                    deleteAction: '@routes.MileStones.delete(project.id)'
                },
                fields: {
                    id: {
                        title: 'Id',
                        list: false,
                        key: true
                    },
                    name: {
                        title: 'Mile Stone',
                        display: function (data) {
                         return '<a href="' + '@routes.Projects.mileStones(project.id)' + '/' + data.record.id + '">' + data.record.name + '</a>';
                        
                        }
                    },
                    description: {
                     title: 'Description',
                     list: false,
                     type: 'textarea'
                    },
                    creationDate: {
                        title: 'Created',
                        type: 'date',
                        create: false,
                        edit: false
                    },
                    dueDate: {
                        title: 'Due Date',
                            type: 'date'
                    },
                    tasksOpened: {
                        title: 'Opened',
                        edit: false,
                        create: false
                    },
                    tasksClosed: {
                        title: 'Closed',
                        edit: false,
                        create: false
                    },
                    project: {
                        title: 'Project',
                        list: false,
                        create: false,
                        edit: false
                    },
                    progress: {
                     display: function (data) {
                     var opened = data.record.tasksOpened;
                     var closed = data.record.tasksClosed;
                     var today = new Date();
                     var due = new Date(data.record.dueDate);
                     if(opened != 0 || closed != 0) {
                         var percentage = Math.round ( (closed * 100) / (opened + closed) );
                     }
                         if(closed == 0) {
                         var percentage = 0;
                         }
                         var progrClass = "progress progress-info";
                         if(due < today) {
                         if(opened > 0)
                         var progrClass = "progress progress-danger";
                         else
                         var progrClass = "progress progress-success";
                         }
                         return '<div class="' + progrClass + '"><div class="bar" style="width: ' + percentage +'%"></div></div>'
                        },
                     create: false,
                     edit: false
                    }
                }
            });
            $('#MilestonesTableContainer').jtable('load');
        });
</script>
}
\end{verbatim}
	\item	High Charts JS - kolejna biblioteka oparta na JavaScript. Także posiada możliwość interaktywnego ładowania danych technologią AJAX.
\end{itemize}

\subsection{Struktura widoków -- pakiet views}
Widoki są plikami w formacie *.scala.html. Są więc źródłami w języku Scala i są kompilowane do plików class. Mają genryczną strukturę. Widoki 
niższego rzędu są generowane poprzez stworzeniu widoku wyższego rzędu z dodaną nową (bardziej szczegółową) treścią. Tak wygląda struktura widoków:

\begin{itemize}
	\item	main.scala.html
	\begin{itemize}
		\item	login.scala.html
		\item	register.scala.html
		\item	index.scala.html
		\begin{itemize}
			\item	milestoneSite.scala.html
			\item	projects.scala.html
			\item	taskSite.scala.html
			\item	projectMain.scala.html
			\begin{itemize}
				\item	contributors.scala.html
				\item	milestones.scala.html
				\item	tasks.scala.html
			\end{itemize}
		\end{itemize}
	\end{itemize}
	\item	header.scala.html
	\item	loginStyles.scala.html
	\item	mainStyles.scala.html
\end{itemize}

Opiszemy dokładniej, jakie znaczenie ma każdy z tych plików.

\begin{enumerate}
	\item main.scala.html -- jest najwyżej w hierarchii. Tak wygląda nagłówek pliku, który jest w pewnym sensie ,,konstruktorem'':
		\begin{verbatim}@(title: String, scripts: Html = Html(""), styles: Html = Html(""))(content: Html)\end{verbatim}
		Oznacza to, że obowiązkowymi parametrami są title(tytuł strony) oraz content (zawartość html). Nieobowiązkowe są skrypty i style. 
		W tym pliku znajduje się sekcje ,,head''.
	\item  	login.scala.html -- jest to widok logowania się do systemu. Przyjmuje takie parametry.
		\begin{verbatim}@(loginform: Form[Application.Login])\end{verbatim} 
		Wymaga podania formularza Form. Używa własnych styli css (loginStyles). Głównym elementem jest właśnie formularz. Dodatkowo, okienko 
		formularza zawiera komunikaty o błędach lub udanych akcjach (flash).
	\item	register.scala.html -- bardzo podobny widok do poprzedniego:
		\begin{verbatim}@(loginform: Form[Application.Register])\end{verbatim} 
		Tym razem otrzymujemy formularz, ale dla obiektu Register. Podobnie informujemy o różnych błędach w znacnziku klasy ,,alert-error''. 
	\item	index.scala.html -- typowy generyczny widok:
		\begin{verbatim}@(active:String, scripts: Html = Html(""))(content: Html)\end{verbatim}
		Parametr active określa nazwę aktywnego komponentu w górnym pasku ,,navbar''. Ten widok składa się właśnie z tego paska oraz z 
		wstawionej pod nim treści (parametr content).
	\item	milestoneSite.scala.html -- Strona szczegółowa kamienia milowego.
		\begin{verbatim}@(milestone: MileStone)\end{verbatim}
		Argumentem jest kamień milowy, którego szczegółowe dane wyświetlamy.
	\item	taskSite.scala.html -- Strona szczegółowa zadania
		\begin{verbatim}@(task: Task)\end{verbatim}
		Argumentem jest obiekt zadania. U góry strony wyświetlamy różne szczegóły dotyczące zadania. Z lewej strony, na dole widoku, ciągnie 
		się lista obiektów HistoryEvent (elementów historii). Z prawej strony, pod detalami zadania, widzimi formularz wysyłania komentarzy.
		Jeszcze niżej formularz raportowania godzin pracy, a pod nim tabelkę jTable z raportami z pracy nad tym zadaniem. Tabelka nie ma 
		możliwości dodawania, edycji ani usuwania. Biblioteka jTable jest tu zastosowana przede wszystkim, aby pozostało to wizualnie 
		spójne z innymi tabelkami.
	\item	projects.scala.html -- strona z projektami użytkownika. Można tu dodawać nowe projekty i podglądać istniejące.
		\begin{verbatim}@(projectForm: Form[Project], ownedProjects: List[Project], contribProjects: List[Project])\end{verbatim}
		Jednym z argumentów jest formularz projektu. Inne to listy projektów: tych, których użytkownik jest właścicielem (ownedProjects) 
		oraz tych, w których zwyczajnie uczestniczy (contribProjects). Wciśnięcie przycisku ,,Add new project'' powoduje pojawienie się 
		dynamicznie formularza dodawania projektu. Wpisujemy tam nazwę oraz opcjonalny opis.
	\item	projectMain.scala.html -- generyczny widok projektu:
		\begin{verbatim}@(active:String, project: Project, scripts: Html = Html(""))(content: Html=Html(""))\end{verbatim}
		Zawiera pasek nawigacyjny projektu (Tasks, Mile Stones, Contributors, Graphs). Parametr active wskazuje, który element paska 
		nawigacyjnego będzie podświetlony. Argument project to projekt, którego strona ma być renderowana. Argument scripts jest przekazywany 
		z widoków niższego poziomu. Argmuent content to treść html wpisywana poniżej paska nawigacyjnego. Można tam wstawić jedą z następujących  			stron.
	\item	contributors.scala.html -- tabelka z członkami projektu. Argumentem jest projekt:
		\begin{verbatim}@(project: Project)\end{verbatim}
		Strona zawiera jedynie tabelkę jTable z możliwością dodawania, edycji oraz usuwania. Dodając użytkownika, możemy wybrać jego rolę.
	\item	milestones.scala.html -- tabelka z kamieniami milowymi projektu. Argumentem jest projekt:
		\begin{verbatim}@(project: Project)\end{verbatim}
		Głównym elementem jest interaktywna tabelka. Poza podstawowymi operacjami, zawiera kilka dodatkowych elementów pisanych w JavaScript. 
		W jeden kolumnie tabelki widzimy pasek postępu zadań. Jeśli minął już termin realizacji zadania, pasek postępu jest czerwony (o ile 
		nie wszystkie zadania zostałyjeszcze zrobione).
	\item	tasks.scala.html -- tabelka z zadanaimi projektu. Argumentem jest projekt:
		\begin{verbatim}@(project: Project)\end{verbatim}
		Głównym elementem jest interaktywna tabelka jTable. Tabelka zawiera trochę funkcji w JavaScript. Funkcje te zamieniają niektóre elementy 
		tekstowe na obrazki, etykiety oraz ikony. Dzięki temu wszystko lepiej wygląda i można szybciej wizualnie odróżniać elementy. Również 
		w wypadku daty realizacji zadania został wprowadzony element graficzny - jeśli termin upłynął a zadanie nie jest zamknięte, data świeci 
		się na czerwono
	\item	Pozostałem pliki są pomocnicze. Mogą w zasadzie także być wydzielone do zasobów statycznych w katalogu ,,public''.
	
\end{enumerate}

\chapter{Instrukcja uruchamiania}
\section{Wymagane oprogramowanie}
\begin{itemize}
	\item	Java 1.7 lub nowsza
	\item	Play 2.1.1
	\item	PostgreSQL 9.1 lub nowszy
	\item	Przeglądarka internetowa
	\item	(dev) IDE dobrze wspierające framework Play, np: Intellij, Eclipse
\end{itemize}

\section{Baza danych}
Należy utworzyć bażę danych PostgreSQL. Aplikacja będzie próbowała łączyć się z bazą określoną
nastepującymi parametrami:
\begin{verbatim}
# PostgreSQL configuration :
db.default.driver=org.postgresql.Driver
db.default.url="jdbc:postgresql://localhost:5432/tms"
db.default.user=postgres
db.default.password=1234
\end{verbatim}

Parametry te można zmienić w pliku \kod{conf/application.conf}. \de

Jeśli baza PostreSQL nie zostanie utworzona aplikacja utworzy bazę pamięciową H2 ---
pod warunkiem, że odkomentujemy zastępujące linie:
\uwaga{Po zamknięciu serwera dane z bazy H2 są tracone.}
\begin{verbatim}
# H2 configuration :
# db.default.driver=org.h2.Driver
# db.default.url="jdbc:h2:mem:play"
\end{verbatim}

\section{Uruchamianie serwera lokalnie}
Uruchamiamy serwer aplikacji wydając w głównym katalogu komendę \kod{play run}.\\
Aplikacja się uruchamia a następnie nasłuchuje na porcie 9000 protokołu HTTP.\\


\section{Uruchamianie aplikacji w przeglądarce}
Podczas uruchamiania aplikacji na środowisku lokalnym aplikacja nie zajmuje żadnego kontekstu
--- aby przejść do strony głównej należy w przeglądarce wybrać adres \kod{http://localhost:9000/}\de

W przypadku braku danych w bazie będzie ją należało spopulować --- należy wybrać ,,Apply this script now!''
\begin{figure}[H]
\centering
\includegraphics[scale=0.8]{images/run.png}
\caption{Pierwsze uruchomienie - populowanie bazy danych}
\label{fig:populate}
\end{figure}


\chapter{Działanie aplikacji}
Poniższe screeny wraz z komentarzami przedstawiają działanie aplikacji.

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{images/app/1.png}
\caption{Panel logowania do systemu}
\label{fig:app_login}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[scale=0.6]{images/app/2.png}
\caption{Rejestracja nowego użytkownika --- obecnie nie ma żadnych ograniczeń -- mechanizm rejestracji można dalej udoskonalić}
\label{fig:app_register}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{images/app/3.png}
\caption{Panel zmiany hasła użytkownika}
\label{fig:app_passwd}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[scale=0.6]{images/app/4.png}
\caption{Widok projektów zalogowanego użytkownika}
\label{fig:app_projects}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{images/app/5.png}
\caption{Lista tasków w danym projekcie}
\label{fig:app_tasks}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{images/app/6.png}
\caption{Statystyki zaraportowanych do danego zadania godzin pracy}
\label{fig:app_hours}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[scale=0.46]{images/app/7.png}
\caption{Podgląd kamieni milowych projektu}
\label{fig:app_milestones}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{images/app/8.png}
\caption{\textit{Burndownchart} obrazujący postęp prac oraz opóźnienia w realizacji projektu}
\label{fig:app_login}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{images/app/9.png}
\caption{Przykładowa walidacja uprawnień do wykonywania akcji przez użytkownika}
\label{fig:app_RBAC}
\end{figure}


\chapter{Testy systemu}

\section{Testy walidacyjne}
Przygotowane przez nas testy walidacyjne obejmują zestaw scenariuszy dowodzących, że system spełnia wymagania i założenia. 
Opiszemy, jakie kroki należy wykonać, aby uznać, że dana funkcjonalność jest spełniona. Zwrócimy uwagę na sytuacje charakterystyczne i wyjątkowe. 
Część trych testów została zautomatyzowana. Część automatyczna jest opisana w rozdziale ,,Testy weryfikacyjne''.

\subsection{Logowanie się}
\subsubsection{Poprawne logowanie}
\begin{enumerate}
	\item	Użytkownik tworzy konto w systemie rejestrując się.
	\item	Wybierając następnie opcję logowania wpisujemy podane wcześniej login i hasło.
	\item	Aplikacja powinna przekierować użytkownika na stronę z jego projektami.
\end{enumerate}

\subsubsection{Nieprawidłowe logowanie --- złe hasło}
\begin{enumerate}
	\item	Użytkownik tworzy konto w systemie rejestrując się.
	\item	Wybierając następnie opcję logowania wpisujemy podane wcześniej login i oraz inne hasło.
	\item	Aplikacja powinna pozostać na tej samej stronie wyświetlając tylko komunikat
		,,Wrong login or password''
\end{enumerate}

\subsubsection{Nieprawidłowe logowanie --- nieistniejący użytkownik}
\begin{enumerate}
	\item	Użytkownik tworzy konto w systemie rejestrując się.
	\item	Wybierając następnie opcję logowania wpisujemy login nieistniejący w systemie i oraz dowolne hasło.
	\item	Aplikacja powinna pozostać na tej samej stronie wyświetlając tylko komunikat
		,,Wrong login or password''
\end{enumerate}


\subsection{Rejestracja}
\subsubsection{Rejestracja poprawna}
\begin{enumerate}
	\item	Użytkownik tworzy konto w systemie podając nieistniejący login \ldots
	\item	\ldots oraz podając 2 razy to samo hasło.
	\item	Aplikacja powinna przekierować użytkownika na listę jego projektów
\end{enumerate}

\subsubsection{Rejestracja niepoprawna --- istniejący login}
\begin{enumerate}
	\item	Użytkownik tworzy konto w systemie podając istniejący login \ldots
	\item	\ldots oraz podając dowolne 2 hasła
	\item	Aplikacja powinna pozostać na tej samej stronie wyświetlając tylko komunikat
		,,Login already in use''
\end{enumerate}

\subsubsection{Rejestracja niepoprawna --- źle powtórzone hasło}
\begin{enumerate}
	\item	Użytkownik tworzy konto w systemie podając nieistniejący login \ldots
	\item	\ldots oraz podając 2 różne hasła
	\item	Aplikacja powinna pozostać na tej samej stronie wyświetlając tylko komunikat
		,,Password not confirmed''
\end{enumerate}

\subsection{Ochrona przed obsługą złych metod HTTP}
\begin{enumerate}
	\item	Zalogowany użytkownik wpisuje w polu adresu w przeglądarce (metoda GET)
			adres, który powinien być dostępny tylko poprzez metodę POST HTTP, np:
			\kod{http://localhost:9000/addProject}.
	\item	Aplikacja powinna wyświetlić błąd ,,Action not found''
\end{enumerate}


\subsection{Ochrona stron przed niezalogowanym użytkownikiem}
\begin{enumerate}
	\item	Niezalogowany użytkownik wpisuje URL, który powinien być dostępny tylko po zalogowaniu,
		np: \kod{http://localhost:9000/projects}.
	\item	Aplikacja powinna pozostać przekierować użytkownika na panel logowania.
\end{enumerate}

\subsection{Ochrona stron przed użytkownikami o niewystarczających uprawnieniach}
\subsubsection{Ochrona przed nieporzadaną zmianą swoich uprawnień na wyższe}
\begin{enumerate}
	\item	Użytkownik loguje się.
	\item	Uzytkownik wybiera projekt, w którym jest tylko kontrybutorem.
	\item	Użytkownik przechodzi do listy kontrybutorów.
	\item	Użytkownik wybiera edycję swojego statusu w projekcie i zmienia do na administratora
	\item	Aplikacja powinna wyświetlić błąd: ,,You are not allowed to do this.''
\end{enumerate}

\subsubsection{Ochrona przed nieporzadaną zmianą swoich uprawnień na wyższe}
\begin{enumerate}
	\item	Użytkownik loguje się.
	\item	Uzytkownik wybiera projekt, w którym jest tylko kontrybutorem.
	\item	Użytkownik przechodzi do listy kontrybutorów.
	\item	Użytkownik wybiera dodawanie knowego kontrybutora
	\item	Aplikacja powinna wyświetlić błąd: ,,You are not allowed to do this.''
\end{enumerate}


\subsection{Ochrona stron przed niepoprawnymi danymi}
\subsubsection{Dodawanie nieistniejącego użytkownika do projektu}
\begin{enumerate}
	\item	Użytkownik loguje się.
	\item	Uzytkownik wybiera projekt, w którym jest administratorem.
	\item	Użytkownik przechodzi do listy kontrybutorów.
	\item	Użytkownik wybiera dodawanie nowego współpracownika --= przycisk ,,Add new record''
	\item	Jako user podajemy losowy ciąg znaków - nieistniejący login
	\item	Aplikacja powinna wyświetlić błąd: ,,No such user in the system.''
\end{enumerate}


\section{Testy weryfikacyjne}
Automatyczne testy weryfikacyjne obejmują dwa obszary:
\begin{enumerate}
	\item	testy jednostkowe -- testy pojedynczych klas, zwłaszcza kontrolerów (pakiet controllers). W Play! Framework najłatwiej 
		jest testować kontrolery w środowisku testowym aplikacji z testową bazą danych i takie rozwiązanie wykorzystujemy.
	\item	testy integracyjne -- testy automatyczne Selenium. Wykorzystują przeglądarkę Firefox. Na bieżąco obserwujemy działanie 
		testów w przeglądarce. Jest to sposób testowania integracji modułów przez badanie tego, co ostatecznie trafia do użytkownika.
\end{enumerate}


\subsection{Testy jednostkowe}
Napisano testy jednostkowe dla metod i klas odpowiedzialnych między innymi za:
\begin{itemize}
	\item	logowanie (poprawne, złe hasło, puste hasło)
	\item	rejestrację (poprawną, niepoprawną)
\end{itemize}


\addtocounter{page}{-1}

\begin{thebibliography}{9}
\bibitem{redmine}
	\href{http://www.redmine.org/projects/redmine/wiki/}{Redmine - Strona Wiki}
\bibitem{gwt}
	\href{https://developers.google.com/web-toolkit/}{Google Web Toolkit}
\bibitem{vaadin}
	\href{https://vaadin.com/book/vaadin7/-/page/architecture.html}{Vaadin Architecture}
\bibitem{play}
	\href{http://www.playframework.com/}{Play! Framework}
\bibitem{jTable}
	\href{http://jtable.org/}{jTable Plugin}
\bibitem{highcharts}
	\href{http://www.highcharts.com/}{High Charts JS}
\bibitem{bootstrap}
	\href{http://twitter.github.io/bootstrap/}{Twitter Bootstrap}
\bibitem{ebean}
	\href{http://www.avaje.org/}{Avaje Ebean}

\end{thebibliography}


\label{LastPage}\phantom{\phantomsection{LastPage}}
\end{document}
