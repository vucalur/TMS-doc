\documentclass[a4paper,12pt,notitlepage]{mwrep}
%%\documentclass[polish,11pt,a4paper,twosides]{article}
%%%\usepackage{fullpage}

\usepackage{./mystyle}

\begin{document}

% footer only for title page:
\newcommand{\cfoottext}{Kraków, \today}
\renewcommand{\footrulewidth}{0.4pt}
\cfoot{\cfoottext}

\begin{titlepage}
\begin{center}
  \resizebox{\textwidth}{!}{\mbox{AKADEMIA GÓRNICZO-HUTNICZA}}\\
  \vspace{2ex}
  \resizebox{\textwidth}{!}{\mbox{Wydział Informatyki, Elektroniki i Telekomunikacji}}\\
  \vspace{4ex}
  \includegraphics[scale=0.15]{images/agh_crop.pdf} \\
  \vspace{4ex}
  \begin{large}KATEDRA INFORMATYKI\end{large} \\
  \vspace{8ex}
  \textbf{\begin{Huge}System prowadzenia zadań w projektach IT\end{Huge}} \\
  \vspace{3ex}
  \textit{\begin{Large}codename: \codename\end{Large}} \\

  \vspace{2cm}
  \begin{Large}\wersja\end{Large}\\
    \vspace{2cm}
\end{center}
\begin{large}
  \begin{tabularx}{\textwidth}{lXc}
    \textit{Kierunek, rok studiów} &  & \textit{ } \\
    \hspace{3em}Informatyka, rok III &  &  \\
    \textit{Przedmiot} &  & \\
	\multicolumn{3}{l}{\hspace{3em}Inżynieria Oprogramowania} \\
    \textit{Prowadzący przedmiot} &  & \textit{rok akademicki:} \hfill 2012/2013\\
    \hspace{3em}\minibox{dr inż. Małgorzata Żabińska-Rakoczy\\dr inż. Jarosław Koźlak} &  & \textit{semestr:} \hfill 6\\
  \end{tabularx}
\end{large}


\vspace{2ex}

\noindent
\begin{Large}
Skład zespołu:\end{Large}
\begin{large}
  \newlength{\tblwidth}
  \setlength{\tblwidth}{\textwidth}
  \addtolength{\tblwidth}{-3em}
  \begin{flushright}
    \begin{tabularx}{\tblwidth}{lXr}
      Grzegorz Wilaszek &  &  \\
      Wojciech Krzystek &  &  \\
    \end{tabularx}\end{flushright}
  \end{large}
  \thispagestyle{fancy}
\end{titlepage}



\onehalfspacing

\lhead{\footnotesize{Grzegorz Wilaszek, Wojciech Krzystek}}
\lfoot{\footnotesize{\codename}}
\cfoot{\normalsize Strona \thepage \ z \pageref{LastPage}}
\rfoot{\scriptsize{\wersja}}

%\setcounter{secnumdepth}{2}
%\setcounter{tocdepth}{2}	% 2 - ToC will contain only subsections


\vfill
\begin{center}
\singlespacing
\fbox{\begin{minipage}{0.8\textwidth}
\footnotesize Niniejsze opracowanie powstało w trakcie i jako rezultat zajęć dydaktycznych z przedmiotu 
wymienionego na stronie tytułowej, prowadzonych w Akademii Górniczo-Hutniczej w Krakowie
(AGH) przez osobę (osoby) wymienioną (wymienione) po słowach ,,Prowadzący przedmiot''
i nie może być wykorzystywane w jakikolwiek sposób i do jakichkolwiek celów, 
w całości lub części, w szczególności publikowane w jakikolwiek sposób
i w jakiejkolwiek formie, bez uzyskania uprzedniej, pisemnej zgody tej
osoby (tych osób) lub odpowiednich władz AGH.
\vspace{2ex} \\
\textbf{Copyright \textcopyright \the\year\ Akademia Górniczo-Hutnicza (AGH) w Krakowie}
      \end{minipage}
}
\onehalfspacing
\end{center}

\tableofcontents


\setcounter{page}{0}
\chapter{Wizja}




\section{Opis systemu}
System prowadzenia zadań w projektach IT ma być w pełni samodzielną (ang. standalone)
aplikacją webową ułatwiającą pracę w zespołach programistycznych (\href{http://en.wikipedia.org/wiki/Issue_tracking_system}{Ticket tracking system}).
Narzędzie sposobem działania będzie przypominało istniejące systemy, np: Redmine, Trac, Jira.\\
Użytkownicy będą mogli tworzyć zadania (ang. tickets, issues, tasks), zmieniać ich status, logować godziny.
Narzędzie służy monitorowaniu prac nad całym realizowanym przedsięwzięciem programistycznym jaki pracy poszczególnych członków zespołu.\\
System będzie tworzony “od zera”, nie będzie rozwinięciem istniejącej aplikacji,
jak i nie będzie korzystał z zewnętrzych zasobów (Web Servisy, itp.).\\	
Jako wzorce funkcjonalności jakich powinien dostarczać taki system obieramy
istniejące rozwiązania uzupełnione o autorskie pomysły.
Podstawą naszej koncepcji jest stworzenie aplikacji webowej, z której mogłyby korzystać różne zespoły:
firmy, instytucje oraz, może przede wszystkim, grupy niezależnych programistów zrzeszonych
w tworzeniu jakiegoś projektu, z szczególnym naciskiem na tworzenie tzw. otwartego oprogramowania
(ang. open source). Dostępne na rynku rozwiązania, nawet jeśli są darmowe, wymagają uruchomienia
aplikacji na własnym serwerze. Jest to oczywiście dużym plusem, jeśli chodzi o politykę prywatności
i bardzo odpowiada dużym firmom i organizacjom, jednak dla wielu projektów
(zwłaszcza w przypadku oprogramowania otwartego) takie rozwiązanie wydaje się być zbyt ciężkim,
czasochłonnym oraz pracochłonnym. Wysiłek poświęcony na skonfigurowanie środowiska jest zbędny
w przypadku mniejszych projektów. Znacznie lepiej byłoby móc założyć profil projektu na łatwo
dostępnym portalu i włączyć wszystkich członków zespołu do przedsięwzięcia. Umożliwołoby to także
łatwą organizację projektu bardzo małym zespołom, nawet grupom studentów pracyjących nad wspólnym projektem.\\
Dodatkowym atutem byłaby jednoczesna możliwość pobrania aplikacji i wykorzystanie jej na własnym serwerze.
Dzięki temu oprogramowanie byłoby postrzegane jako odpowiadające różnym wymogom bezpieczeństwa,
np. dzięki ukryciu wszystkich zasobów firmy za firewall’em.




\section{Motywacja}
Motywacją naszego pomysłu było zetknięcie się z dużymi systemami do zarządzania projektami:
\begin{description}
	\item[IBM Rational Team Concert]
		Jest to komercyjny projekt firmy IBM. Bardzo drogi,
		ale także o bardzo dużych możliwościach.
		Łączy zarządzanie projektem w metodologiach “zwinnych” (ang. “agile”)
		z systemem kontroli wersji. IBM udostępnia specjalną wersję
		Eclipse IDE (Rational Team Concert Eclipse) oraz wtyczki do zwykłego Eclipse’a.
		Pozwala na bardzo przejrzyste łączenie zadań z kodem w projekcie.
		Możliwości jest bardzo dużo. Najlepszym przykładem jest opcja zaznaczenie
		fragmentu kodu i sprawdzenia , przez kogo został dodany lub zmodyfikowany
		oraz częścią jakiego zadania były te zmiany. Wadą oprogramowania RTC jest
		przede wszystkim jego cena. Ponadto wymaga dużego nakładu administracyjnego,
		ponieważ ma wiele możliwości i parametrów do skonfigurowania.
		Nadaje się zatem tylko dla bardzo dużych firm. 
	\item[Redmine]
		Redmine jest darmowym i otwartym, webowym narzędziem do zarządzania projektami
		i śledzenia błędów. Zawiera kalendarz i wykresy Gantta do wspomagania wizualnego
		przedstawiania projektów i ich terminów. Obsługuje wiele projektów.
		Redmine zapewnia zintegrowane funkcje zarządzania projektami, śledzenie błędów
		i wsparcie dla różnych systemów kontroli wersji. Wyraźny wpływa na Redmine’a
		miał projekt \textbf{Trac}, pakiet o podobnych cechach. Redmine jest napisany
		z wykorzystaniem Ruby on Rails i wymaga uruchomienia na własnym serwerze.
		Jest to właśnie pierwszy aspekt, w któym chcemy wprowadzić pewną nowość
		przez skoncentrowanie usług na jednym portalu. Drugim elementem, gdzie
		chcemy wprowadzić innowacje, jest zasób narzędzi, gdyż Redmine nie oferuje
		wszystkich przydatnych sposobów graficznej prezentacji przebiegu projektu.
		Ogromną zaletą projektu Redmine jest oczywiści jego dostępność bez żadnych opłat
\end{description}
Są to dwa największe systemy, z którymi spotkaliśmy się podczas praktyk zawodowych.
Jakiś czas później, rozpoczynając nowe projekty uczelniane, szukaliśmy podobnych,
lecz lżejszych (i w przeciwieństwie do IBM Rational Team Concert - darmowych),
rozwiązań. Istnieją pewne szybkie w użyciu portale do prowadzenia projektów,
jednak nie są one skoncentrowane stricte na projektach informatycznych,
dlatego brakuje im wielu przyfatnych dla programistów funkcjonalności.
W obsługę zadań (ang. “tasks”, “issues”) są wyposażone niektóre hostingowe
serwisy internetowe przeznaczone dla programistów korzystających z kontroli wersji,
zwłazcza oprogramowania Git, takie bittbucket.org bądź github.org.
Ich wadą jest przede wszystkich niezbyt szeroki zakres funkcjonalności, na przykład:
\begin{itemize}
	\item	brak wyraźnego połączenia zadań z kodem (bitbucket)
	\item	brak możliwości oznaczania różnych parametrów zadań,
			np: priorytet, zagrożenie związane z błędem lub brakiem zaimplementowanej funkcjonalności (zwłaszcza github).
	\item	brak możliwości oznaczania zadań jako powiązane (np. relacja “rodzic - dziecko”)
\end{itemize}
Dodatkową wadą jest też oczywiście powiązanie danych projektu
(zadania, komentarzy itd.) z konkretnym repozytorium!
Z jednej strony jest oczywiście wyjątkowo mało elastyczne w pracy,
ale przede wszystkim pojawia się olbrzymi problem, jeśli chcemy przeniść
projekt do innego repozytorium (np. zrezygnować z otwartości projektu
a tylko taką opcję udostępnia github). Tracimy wówczas całą historię projektu.
Wszystkie zadanie, komentarze, wszystkie dane. Mimo to, wiele niedużych
zespołów wybiera zarządzanie projektami na takim serwisie, gdyż jest
to dla nich najprostsze wyjście. Chcielibyśmy, aby nasza aplikacja była
rozwiązaniem takiego problemu. Aby była elastyczna i prosta w użyciu.
Aby rozpoczęcie pracy nad nowym projektem trwało dosłownie chiwlkę.




\section{Innowacyjność}
Uważamy, że chociaż istnieje kilka rozwiniętych przedsięwzięć,
zajmujących się tą tematyką, wciąż można znaleźć luki do uzupełnienia
w puli tych rozwiązań. Naszym celem nie jest mierzenie w kompleksowość
usług na poziomie IBM Rational Team Concert, ale dodanie paru pomysłów
do rozwiązań w stylu oprogramowania Redmine. Chodzi głównie o wizualizację
parametrów pracy nad projektem, zwłaszcza tzw. “burn down chart” (brak popularnej polskiej nazwy).
Jest to bardzo przydatny wykres do monitorowania postępu prac w projekcie.
Analogicznym wykresem jest wykres przedstawiający ilość spodziewanych zgłaszanych
w czasie defektów z jednoczesną linią obrazującą rzeczywistą ilość raportowanych błędów.
Jest to bardzo ważne w technikach zwinnych (ang. “agile”) do analizy postępu i jakości pracy.




\section{Rodzaj aplikacji}
Nasza aplikacja, jak już wcześniej wspomnieliśmy, byłaby aplikacją webową z własną bazą danych.
Ważną cechą będzie możliwość uruchomienia centralnego serwisu internetowego,
z którego będą mogli koszystać wszyscy programiści na świecie. Będą mogli zakładać wiele projektów.
Z drugiej strony możliwe będzie pobranie aplikacji postawienie serwera z własną kopią serwisu,
dzięki czemu użytkownik będzie mógł ukryć wszystkie dane we własnej sieci i nie będzie
uzależniony od obciążenia centralnego serwisu. Jest dodatkowo istotnym czynnikiem
przy wyborze technologii, w której zaimplementujemy system. Musi być możliwe bardzo
lekkie uruchomienie środowiska (jak np. w Django bądź Play! Framework, przez wydanie
prostej komendy “run” w terminalu), ale jednocześnie muszą być dostępne wielkoskalowe
i wydajne rozwiązania, dostosowane do używania aplikacji przez tysiące użytkowników.
Musimy zatem wybrać technologię wspierającą oba warianty.




\section{Szczegółowa koncepcja}
Użytkownik będzie korzystał w przeglądarce WWW z webowego interfejsu aplikacji.
Odwiedzając stronę, będzie miał początkowo do czynienia z funkcjonalnością opisaną w następującym podpunkcie.

\subsection{Pierwsze kroki użytkownika w aplikacji}
Wchodząc na stronę internetową, użytkownik zobaczy panel logowania.
Niezalogowany użytkownik będzie miał dostęp praktycznie tylko do tej podstrony.
Ewentualnie, będzie miał kilka dostępnych zakładek z informacjami o produkcie,
danymi kontaktowymi, czy też z formularzem rejestracyjnym. Samo istnienie funkcjonalności
rejestracji użytkowników jest do rozpatrzenia. Można rozważyć udostępnienie uwierzytelniania
poza naszym serwisem, na przykład za pomocą kont mailowych na gmail’u.

\subsection{Organizowanie nowego projektu}
Zalogowany użytkownik będzie mógł założyć nowy projekt. Będzie mógł podać
różne dane opisowe tego projektu: wykorzystywane technologie, przewidywany
czas realizacji itp. Ponadto, będzie mógł zapraszać osoby do projektu
a także przyjmować wnioski użytkowników o nadanie praw do wprowadzania zdarzeń w projekcie. 

\subsection{Kamienie milowe}
Ważnym zagadnieniem są kamienie milowe. Do nich będą przyporządkowywane zadania.
Kamienie milowe będą miały swoje daty realizacji. Można przewidzieć hierarchiczną
strukturę zbioru kamieni milowych. Dzięki temu będzie można przykładowo wyznaczyć
półroczny kamień milowy w projekcie i dodatkowo podzielić go na dwu tygodniowe
sprinty, które de facto też będą kamieniami milowymi.

\subsection{Dodawanie nowych zadań}
Użytkownik posiadający uprawnienia do zmian danym projekcie,
będzie mógł dodawać do projektu nowe zadanie. Przewidujemy podstawowe typy zadań, takie jak: 
\begin{itemize}
	\item	zwykłe zadanie
	\item	defekt
	\item	test
	\item	dokumentacja
	\item	ulepszenie
\end{itemize}
Innymi parametrami zadania będzie przewidziany czas (lub data) jego wykonania,
kamień milowy, do którego należy, osoba, która wykonuje to zadanie.
Zadanie będzie także miało swój stan: początkowe będzie otwarte bądź zamknięte.
Później można się także zastanowić nad bardziej szczegółowymi możliwościami.

\subsection{Przeglądanie zadań}
Użytkownik będzie mógł przeglądać zadania z danego projektu.
Będą one wyświtlone w formie interaktywnej listy z możliwością sortowania
oraz filtrowania po podstawowych parametrach: na przykład po kamieniach milowych,
po priorytecie, statusie itp. W tym samym widoku będzie można dodać nowe zadanie
lub usunąć inne. Ten element jest podstawą przejrzystości aplikacji i musi
być wykonany czytelnie, udostępniając intuicyjny i czytelny interfejs.

\subsection{Edytowanie zadania}
Edytowanie zadań obejmować będzie dodawanie komentarzy oraz linków do kodu.
Będzie można zmieniać parametry zadania, takie jak przewidywana data oddania,
osoba pracująca nad zadaniem. W szczególności będzie też można zakończyć zadanie,
zamykając je poprzez wciśnięcie odpowiedniego przycisku.




\section{Użyte technologie}
Całość aplikacji będzie zrealizowana w technologiach Javowych i pokrewnych.

\subsection{Warstwa persystencji}
\subsubsection{Baza danych}
Wybór systemu zarzadzania bazą danych jest prosty: zostanie użyta baza PostgreSQL,
ze względu na:
\begin{itemize}
	\item	darmowość narzędzia
	\item	rozbudowane funkcjonalności (w porównaniu do “lekkich” DMBS, jak np: MySQL, SQLite, HSQL) - nie odstępuje produktom komercyjnym
	\item	dobra wydajność (ustępuje jedynie rozwiązaniom komercyjnym, np: Oracle DB)
	\item	bardzo dobra kompatybilność z frameworkami ORM
	\item	dopracowane i bogate w funkcjonalności narzedzie graficzne do bezpośredniego zarządzania bazą - pgadmin3
\end{itemize}
\subsubsection{Framework ORM}
Zostanie wykorzystany interfejs JPA, zapięty “pod maską” do fremeworku
konkretnego (JPA providera) - Hibernate. Głównie ze względu na wysoką popularność
(co za tym idzie pomoc community), wydajność oraz dojrzałość rozwiązania.

\subsection{Serwer aplikacji - kandydaci}
\begin{itemize}
	\item	Glassfish
	\item	Tomcat
	\item	TomEE
\end{itemize}
Wybierając serwer będziemy kierowali się prostotą obsługi, popularnością, jakością dokumentacji.\\
Wybór serwera aplikacji może zostać dokonany później.

\subsection{Warstwa prezentacji - kandydaci}
\begin{itemize}
	\item	\textbf{Spring MVC}
	\item	\textbf{GWT / Vaadin / GXT}\\
			Rodzina technologii (GWT jest jej prekursorem, GXT oraz Vaadin to rozszerzenia)
			pozwalająca tworzyć bogate aplikacje webowe (RIA) bezpośrednio w języku Java,
			korzystając z wygodnego API.\\
			Taki wysokopoziomowy kod pośredni jest następnie kompilowany przez framework do
			technologi docelowej - JavaScript.\\
			Warto wspomnieć, iż GXT i Vaadin różnią się technologicznie - Vaadin realizuje
			koncepcję cienkiego klienta, GXT - grubego (większość akcji jest kompilowana
			do dynamicznego JavaScriptu przeznaczonego na przeglądarkę klienta).
	\item	Play! framework (wersja dla Javy)
\end{itemize}
W warstie prezentacji zostało wyszczególnionych wiele kandydatów
do bycia technologią docelową. Po głębszym zapoznaniu się z technologiami i wstępnych próbach
zostanie podjęta decyzja.\\
Rozważamy również utworzenie aplikacji w frameworku “lekkim”, np: Django, Ruby On Rails.\\
Niezależnie od wybranej w tej w warstwie technologii, będzie ona bazowała
(będzie zrealizowana “pod maską”) na technologii JavaScript, dotyczy to również
technologii opartych na językach innych niż Java.

\subsection{Technologie - ostateczny wybór}
Po szczegółowej analizie przedstawionych wyżej możliwości, zdecydowaliśmy,
że zrealizujemy projekty w technologii Play! Powody naszego wyboru są następujące:
\begin{itemize}
	\item	Framework Play! jest prosty i nowoczesny. Jest uważany za przełom w świecie Javy.
			Łączy wydajność z prostotą. Jest postrzegany jako bardzo przyjazny dla programistów.
			Proponuje bardzo ciekawe rozwiązania, które już na pierwszy rzut oka pokazują,
			że technologia umożliwia pisanie krótszego i bardziej czytelnego kodu w najbardziej
			popularnym języku programowania - Javie. Jest to osiągnięte przez rezygnację
			z pewnych standardów programowania w Javie.
	\item	Możliwości uruchomienia serwera aplikacji są bardzo elastyczne i dostosowane
			do naszych (wyżej opisanych) potrzeb. 
	\item	Play! Framework do persystencji domyślnie używa biblioteki Avaje Ebean. Jest to framework 
			bazujący na adnotacjach JPA, dostarczający interfejs znacznie wyższego poziomu niż 
			implementacje JPA, takie jak Hibernate. Znacznie prostsza jest tranzakcyjność, pisanie 
			zapytań a także wiele możliwości dostarczają adnotacje dla persystentnych pól, dodając 
			na przykład kontekst szyfrowania tajnych danych.
	\item	Framework obsługuje dwa języki programowania: Java i Scala. Można pisać kod w obu językach w ramach 
			jednego projektu. Daje to bardzo duże możliwości, jako że Java jest językiem niezwykle 
			popularnym, a Scala nowoczesnym i mającym duże perspektywy. 
 
\end{itemize}
Framework Play! jest dostępny w dwóch wersjach: dla języka Scala (pracującego na wirtualnej
maszynie Javy) oraz dla samej Javy. Zdecydowaliśmy się, póki co, na tę drugą opcję, ponieważ:
\begin{itemize}
	\item	Można łatwo wykorzystywać inne bibloioteki i technologi, chociażby takie jak Spring
	\item	Sami mamy większe doświadczenie w Javie
	\item	Łatwiej jest korzystać z technologi wykorzystywanych przez Play!, np. Hibernate
	\item	Biorąc pod uwagę perspektywę rozbudowy systemu, łatwiej będzie wdrożyć się nowym programistom,
			jeśli aplikacja będzie napisana w Javie
\end{itemize}

\subsection{Baza danych}
Wybraliśmy bazę danych PostgreSQL ze względu na jej bardzo dobre opinie. Jest uważana za najlepszy darmowy system zarządzania 
bazą danych. Ponadto, w fazie deweloperskiej będziemy korzystać z bazy danych H2, bazy przetrzymującej dane w pamięci. Play! 
Framework zapewnia bardzo łatwe przełączanie między rzeczywistą bazą danych a atrapą H2. Dodatkowo, bazy danych H2 będziemy 
używać do testów automatycznych.

\subsection{Dodatkowe biblioteki}
Kolejnymi, po wyborze głównych technologii, technicznymi wyborami były dodatkowe, wspomagające biblioteki. Na razie 
będziemy potrzebować głównie komponentów graficznych. I tak zdecydowaliśmy się na następujące:
\begin{itemize}
	\item	jTable - biblioteka oparta na jQuery, służąca do prezentacji danych w interaktywnych tabelach. Głównym 
		zastosowaniem będzie z pewnością tabela z zadaniami, ale także z pracownikami projektu czy kamieniami 
		milowymi.
	\item	Highcharts JS - JavaScript'owa biblioteka do prezentacji danych na wykresach. Dostarcza wiele rodzajów 
		wykresów, także interaktywnych. Przydadzą się nam one do prezentowania analiz pracy w projekcie.
	\item	Twitter Bootstrap - biblioteka komponentów html, css o JavaScript do szybkiego tworzenia ładnych i nowoczesnych 
		interfejsów webowych.
\end{itemize}

\begin{center}	
\vspace{4ex}	
	\includegraphics[scale=0.5]{images/jTable.png} \\
	\includegraphics[scale=0.5]{images/highCharts.png} \\
\vspace{4ex}
\end{center}


\section{Zarys architektury}
Przedstawiamy wstępny zarys architekruty systemu. Jest on w dużej mierze podyktowany przez archutekturę technologii Play! Framework. 
Warto także zwrócić uwagę na sposób zwracania rezultatu do przeglądarki klienta. Będzie się odbywała standardowo - przez generowane 
widoki, ale także przez pobieranie danych przez web serwisy - np. w formacie JSON.
\begin{center}	
\vspace{4ex}	
	\includegraphics[scale=1.0]{images/tasksArch.jpg} \\
\vspace{4ex}
\end{center}

\section{Plan działania}
Projekt będzie realizowany w metodologii lekkiej - będziemy chcieli początkowo
zrealizować jedynie podstawowe funkcjonalności takiego systemu, stopniowo dobudowywyjąc
nowe i zwiększając możliwości starych.\\
Pozwoli nam to na lepszą estymację czasu potrzebnego na zrealizowanie dalszych funkcjonalności,
jak i czasu realizacji całego przedsięwzięcia.
\\
\\
Zakładając, że projekt będzie trwał do 15-25 czerwca, przyjęliśmy na początku następujący harmonogra:
\begin{itemize}
	\item	29/04/13 - logowanie i rejestracja
	\item	06/05/13 - panel użytkownika
	\item	13/05/13 - dodawanie projektu i kamieni milowych
	\item	20/05/13 - dodawanie zadań
	\item	27/05/13 - dodawanie współpracowników,
	\item	przypisywanie roli administratora współpracownikowi
	\item	10/06/13 - panel zadania: komentarze, zmiana stanu
		zadania
	\item	17/06/13 - kilka przykładowych wykresów

\end{itemize}




\section{Wymagania -- etap 1}
Etap ma za zadanie dostarczenie stosunkowo szybko “czegoś działającego” do klienta,
jak również potwierdzenie wykonalności całego zadania.\\
Jednym z ważnych podcelów tego etapu będzie decyzja co do używanej technologii.
\paragraph{Funkcjonalne}
\begin{itemize}
	\item	W pełni działający mechanizm kontroli dostępu oraz podział użytkowników na role
	\item	Formularz zakładania nowego projektu
	\item	formularz tworzenia nowego taska
	\item	formularz edycji istniejącego taska
	\item	lista --- widok wszystkich tasków, z ew. sortowaniem
	\item	Widok wszystkich projektów danego użytkownika
\end{itemize}
\paragraph{Niefunkcjonalne}
\begin{itemize}
	\item	brak autentykacji, brak kontroli dostępu do systemu (w zależności od terminu
			oddania pierwszego prototypu możliwość zrezygnowania z tego ograniczenia)
	\item	system działający już na własnej bazie
	\item	niekoniecznie gotowa konfiguracja środowiska produkcyjnego --- pokaz na środowisku deweloperskim
	\item	brak testów jednostkowych oraz akceptacyjnych, brak podejścia TDD na tym etapie
\end{itemize}




\section{Wymagania -- etap 2}
\paragraph{Funkcjonalne}
\begin{itemize}
	\item	rozbudowane filtry w liście wszystkich tasków
	\item	widok użytkowników systemu = pracowników danego projektu
	\item	dodawanie komentarzy do taska
	\item	panel admina --- zarzadzanie projektem, zapraszanie użytkowników do projektu, itp.
\end{itemize}
\paragraph{Niefunkcjonalne}
\begin{itemize}
	\item	autentykacja
	\item	bardziej rozwinięta warstwa pośrednia (middleware)
	\item	testy jednostowe do niektórych funckjonalności
	\item	dopracowany wygląd graficzny aplikacji
\end{itemize}




\section{Przykładowe dalsze możliwości rozbudowy}
Temat prowadzenia projektów jest bardzo szeroki, dlatego nasz projekt ma ogromne możliwości
rozbudowy w przyszłości. Część z przedstawionych pomysłów zostanie zrealizowana.
Nic nie stoi na przeszkodzie, aby pozostałe propozycje zostały kiedyś zrealizowane przez
inne zespoły, bądź przez nas w ramach innych przedmiotów. W skrócie:
\begin{itemize}
	\item	cykl życia tasków, np: new $\rightarrow$ assigned $\rightarrow$ in progress $\rightarrow$ rejected
			z walidacją poprawności obieranych przez taski stanów
	\item	dodatkowe klasyfikowanie tasków, np: priorytet, tagowanie numerem podgrania, własne tagi
	\item	raportowanie czasu do poszczególnych tasków
	\item	miesięczne statystyki czasu
	\item	hierarchia tasków (rodzic, dziecko)
	\item	estymaty czasowe, wykresy:
			\begin{itemize}
				\item	\href{http://www.youtube.com/watch?v=XU0llRltyFM&t=4m29s}{Burndown chart}
				\item	monitoring ilości tasków - podział na otwarte i zamknięte (analogcznie jak jest to zrealizowane w narzędziu JIRA:
						\href{https://confluence.atlassian.com/download/attachments/185729486/gadgets-charting-created-vs-resolved.png?version=2&modificationDate=1350347163816&api=v2}{link})
			\end{itemize}
	\item	powiadamianie email, kanały RSS
	\item	rejestracja poprzez emaila aktywacyjnego
	\item	zaawansowany interfejs graficzny, np: avatary użytkowników, itp.
\end{itemize}


\subsection{Organizowanie nowego projektu}
Mając na uwadze potencjalne możliwości rozszerzania projektu w przyszłości,
warto przewiedzieć możliwość dodawania zespołów w projekcie(np. zespół programistów,
testerów bądź bardziej szczegółowy podział). Można również dodać możliwość wyznaczania
w projekcie komponentów lub obszarów. Dalej idąc, można przewidzieć opcję wyznaczenia osoby
odpowiedzialnej za komponent czy też obszar. Ułatwia do współpracą i przyspiesza uzyskania
pomocy w razie wątpliwości, kiedy to inny pracownik pracuje nad tym obszarem projektu.
Ciekawym urozmaiceniem jest także stworzenie możlwiwości dodawania własnych tagów dla projektów.
Przykładowo, jeśli projekt ma wdrożony w najbliższej przyszłości, część zadań można oznaczyć tagiem,
sugerującym, że zadania te są równie ważne jak pozostały, jednak z pewnych względów przewiduje się ich
realizację dopiero w kolejnej wersji produktu.


\subsection{Kamienie milowe}
Kamienie milową są ważną jednostką organizacyjną projektu, dlatego warto wzbogacić je o dodatkowe
wizualizacje i diagramy. Przykładowo procent wykonania przewidzianych zadań itp.


\subsection{Dodawanie nowych zadań}
Ważnym dodatkiem jest stworzenie hierarchicznej budowy zadań.
Tak, aby można było oznaczyć inne zadanie jako rodzic nowego zadanie itp. Możliwe jest
wzbogacenie ilości stanów zadania (np. nowe, oczekujące, w trakcie pracy itp.) Poza tym,
jeśli projekt będzie posiadał swoje obszary lub komponenty, to również zadanie mogłoby mieć
przyporządkowan obszar lub komponent, którego dotyczy. Mogłoby także istnieć dodatkowe pole
na zespół, który ma się zająć tym zadaniem. Dzięki temu odpowiednie osoby szybciej je zobaczą,
natomiast te, które nie mają się nim zajmować, być może w ogóle nie zwrócą na nie uwagi,
ponieważ będą tylko patrzeć na własną kolejkę zadań. Dodatkowo, można w zadaniu przewidzieć
dodatkowe pole na osobę pierwszego kontaktu, byłby to np. programista, która niedawno zajmował
się podobnymi sprawami, ale nie jest odpowiedzialny za dany obszar lub komponent, albo osoba mają
duże doświadczenie w powiązanej z zadaniem technologii.


\subsection{Przeglądanie nowych zadań}
Udostępnienie w systemie dodatkowych atrybutów zadań pozwoli na wzbogacenie srotowania i filtrowania
o te parametry. Można także umożliwić użytkownikom tworzenie własnych, nazwanych kolejek zadań
(prywatnych lub dla całego projektu). Przykładowo, główny architekt systemu dodałby nazwaną kolejkę
“najważniejsze zadania”, która pokazywałaby wszystkie zadania o najwyższym priorytecie, największym
zagrożeniu dla projektu oraz przeznaczący na bieżący kamień milowy (np. sprint).


\subsection{Edytowanie zadania}
Podobnie, jak w poprzednich podpunktach, tutaj także możliwości będą rozbudowane wraz z rozbudową
funkcjonalności systemu oraz przybywaniem nowych właściwości zadań. Dodatkowo, można wprowadzić dodatkowe
stany cyklu życia zadania, takie jak “potrzebuję informacji” (np. deweloper oznacza tak zadanie
i przypisuje je do testera, który zgłosił defekt, aby udzielił bardziej szczegółowej informacji)
oraz “Rozwiązane”, do któego z kolei można będzie przydzielić dodatkowe informacje (np. oznaczyć,
że to zadanie było duplikatem innego zadanie i podać powiązane zadanie). Można także przewidzieć
dodawania linków do zmian w kodzie wprowadzonych wraz z pracą nad tym zadaniem (np. link do commit’u
na githubie). W bardziej zaawansowanej wersji można dobudować bardziej profesjonalny \textbf{moduł integracj
iz systemami kotroli wersji}.


\subsection{Nowe narzędzie w projekcie}
Jeśli system osiągnie kiedyś wysoki poziom rozwinięcia i zaawansowanie, co oznacza zaimplementowanie
w zasadzie wszystkich funkcjonalności wspomnianych w powyższych podpunktach, będzie można zastanowić
się nad dodaniem kolejnych możliwości, już na zasadzie osobnych narzędzi. Podajemy kilka przykładów,
jakie mogłyby to być programy. Propozycje są bardzo luźne i nie zastanawialiśmy się, jak bardzo
złożone byłyby to projekty:
\begin{itemize}
	\item	Wtyczka do Eclipse’a (lub innego popularnego IDE)
	\item	Zaawansowana synchronizacja z systemem kontroli wersji (być może zsynchronizaowana z wtyczką do IDE)
	\item	Aplikacja do obsługi repozytorium w stylu Tortoise Git / Tortoise SVN, umożliwiające dostęp do
			repozytorium z jednoczesnym podpięciem do naszego systemu zarządzania zadaniami
	\item	Narzędzie linii poleceń analogiczne do powyższego
\end{itemize}






\chapter{Specyfikacja logiki aplikacji}
\section{Przegląd istniejących rozwiązań}
\subsection{IBM Rational Team Concert}
Narzędzie IBM RTC oferuje bardzo szerokie możliwości administracji i zarządzania projektem. Jeśli natomiast chodzi o interesujące nas funkcjonalności, Rational Team Concert ma następujące właściwości:
\begin{itemize}
	\item	Użytkownik widzi tylko te projekty, które zostały mu udostępnione przez administratorów projektów. Wcześniej musiał się zalogować. RTC udostępnia wiele mechanizmów uwierzytelniania użytkowników (np. LDAP, osobna baza danych, OAuth itp.)
	\item	Użytkownik otrzymywał prawo dostępu do projektu wówczas, gdy dostał zaproszenie od administratora.
	\item	Użytkownik, w ramach przynależności do projektu, mógł należeć do jednego z zespołów pracujących w projekcie. Można zabronić pracownikom jednego zespołu przypisywania się do zadań przeznaczonych dla innego zespołu, a nawet oglądania tych zadań. Takie restrykcje sprawdzają się w bardzo dużych projektach.
	\item	Mając dostęp do zadania, każdy mógł dodawać komentarze.
	\item	Pewne inne atrybuty zadania (np. priorytet, powiązane komponenty itp.) mogą być modyfikowane przez wszystkich pracowników projektu lub przez wybraną ich część, na przykład: dla zadań będących własnością zespołu ,,A'', których termin oddania jest krótszy niż tydzień, priorytet mogą zmienić tylko menedżerowie i administrator projektu. Daje to oczywiście duże możliwości, ale jednocześnie jest bardzo skomplikowane.
	\item	Zamknąć zadanie może jego właściciel lub inna upoważniona osoba, jeśli zadanie było oznaczone jako ,,completed''(ukończone). Było to ba przykład przydatne, gdy ktoś skończył zadanie, ale nie dostał jeszcze zgody na dostarczenie kodu i właśnie wybiera się na urlop. Często tą opcję wykorzystują studenci, których często nie ma w pracy np. cztery dni pod rząd.
\end{itemize}

\subsection{Redmine}
\uwaga{Poniżej przedstawiono jedynie opis poszczególnej instalacji i konfiguracji systemu Redmine
wykorzystywanej do prowadzenia wielu projektów w małym (kilka osób) zespole programistów
--- Redmine udostępnia rozbudowane możliwości a sposób
w jaki system będzie skonfigurowany jest czynnikiem kształtującym w największej mierze późniejszy
schemat interakcji użytkowników z systemem (łac. \emph{Modus operandi}).\je
Z jednej strony mamy możliwość skonfigurowania systemu według własnych potrzeb, z drugiej strony
nie jest to rozwiązanie w duchu ''\emph{out of the box}''}\de
\begin{description}
	\item[Role użytkowników]
		Role w systemie Redmine dzielą się na:
		\begin{itemize}
			\item	związaną z zarządzaniem samym Redminem: administrator
			\item	role pełnione przez użytkownika w danym projekcie, np:  developer, tester, manager
		\end{itemize}	związaną z zarządzaniem 
		Użytkownik może w danym projekcie mieć wiele ról. Administrator może dodatkowo pełnić role w projektach.
	\item[Uprawnienienia użytkowników]
		Administratorzy mają nieograniczone prawa -- mogą np: zarządzać projektami nieutworzonymi przez siebie,
		czy też usuwać konta innych użytkowników, w tym administratorów.\je
		Tworzyć, modyfikować oraz usuwać projekty może tylko administrator.
		W obrębie jednego projektu wszyscy użytkownicy mogą tworzyć, edytować, zamykać a nawet usuwać
		dowolne zadania. Wszyscy mogą komentować zadania, zmieniać właściciela, testera, zleceniodawcę
		tasków w projekcie, do którego jest zapisany (pełni jakąś rolę).\\
		Każdy ma dostęp odczytu (ale nie zapisu) tasków we wszystkich projektach.\\
		\uwaga{Redmine zapewnia dużo większe możliwości konfiguracji, drobnoziarnistości
		uprawnień, itp. Tutaj przybliżono opis działania pojedynczej instalacji Remdine'a z jaką przyszło nam pracować.}
	\item[Grupowanie tasków]
		Taski przynależą do jednego konkretnego projektu. Nie da się utworzyć tasków nieposiadających
		macieżystego projektu, ani takich które należą do wielu projektów
	\item[Cykl życia tasków]
		Redmine dostarcza w tym zakresie duże możliwości konfiguracji ---
		to administrator zakładając dany projekt określa nazwy stanów tasków, oraz możliwych przejść między nimi.
	\item[Taski]
		Task może mieć pojedycznego wykonawcę (asignee) lub być przypisany do grupy --- jest to jednak rozwiązanie niewygodne,
		gdyż trzeba specjalnie tworzyć grupę.
		Task może na tej samej zasadzie mieć przypisanego testera oraz zleceniodawcę.
		Dowolny użytkownik mający dostęp do projektu danego taska\footnote{Czyli inaczej: pełniący pewną rolę w danym projekcie}
		może doliczać do niego godziny pracy.
	\item[Nawigacja]
		Po zalogowaniu się użtkownik ma dostępne widoki między innymi:
		\begin{itemize}
			\item	Swojej karty czasu pracy
			\item	Widok projektów, do których jest przypisany\\
					Po wybrani danego projektu mamy widok użytkowników w projekcie, zadań, itp.
			\item	Panel użytkownika - edycja danych, preferencji, itp.
		\end{itemize}
	\item[Zarządzanie użytkownikami]
		Tworzyć użytkowników może tylko administrator. Przypisywać role użytkownikom w danym projekcie -- w zależności
		od konfiguracji -- można zablokować taką możliwość, wtedy przypisywaniem ról w projektach zajmuje się jedynie administrator.
	\item[Aspekty techniczne]
		W przypadku usuwania danych jedyny ślad pozostaje po nich w logach aplikacji.
		Użytkownicy mają jednakże możliwość tworzenia kopii zapasowych całego stanu systemu,
		oraz eksport danych danego projektu, zadania, itp. do pliku.
\end{description}




\section{Przyjęte przez nas rozwiązanie}
Nasz system nie będzie konfigurowalny w sposób w jaki konfigurowalne są dwa systemy przedstawione wyżej,
tracimy na uniwersalności, za to użytkownik nie zostaje zniechęcony trzystustronową dokumentacją
samego narzędzia oraz godzinami potrzebnymi na skonfigurowanie systemu do własnych potrzeb.\\
Zamiast tego chcemy dostarczyć produkt, który z domyślnymi ustawieniami adresuje potrzeby dużej rzeszy małych zespołów.\te
Wizja funkcjonalność dla pierwszej iteracji:
\begin{center}	
\vspace{4ex}	
	\includegraphics[scale=0.7]{images/use_case_1.png} \\
\vspace{4ex}
\end{center}
\subsection{Logika aplikacji}
\subsubsection{Konta użytkowników}
\begin{itemize}
	\item	System swoim działaniem będzie przypominał serwisy do hostingu kodu źródłowego, np: bitbucket, github.
	\item	Każdy będzie mógł założyć konto oraz założyć swój projekt.
			Logowanie na nieistniejący login jest traktowane jako rejestracja.
	\item	Właściciel będzie mógł zaprosić do pracy nad projektem innych użytkowników.
	\item	Role i użytkownicy są oddzielnymi bytami -- role danego użtkownika są osobne dla każdego projektu.
			Użytkownik może nie mieć żadnych roli do danego projektu.
	\item	Nie istnieje rola administratora systemu.
\end{itemize}

\subsubsection{Role Użytkowników}
\begin{itemize}
	\item	Brak podziału na role tester, developer, itp. w kontekście projektu.
			Jeśli jest potrzeba przetestowania pewnej funkcjonalności spisuje się na to osobnego taska,
			osoba go realizująca jest tym samym \emph{testerem} tej funkcjonalności.
	\item	Właściciel projektu jest jego administratorem. Administratorzy projektu mogą nadawać innym
			użytkownikom w projekcie rolę administratora.
	\item	Administrator może odebrać uprawnienia do projektu innym użytkownikom, w tym administratorom,
			także sobie. Wyjątkiem jest właściciel projektu: nie mogą mu być odebrane prawa administratora danego projektu.
	\item	Jest przetrzymywana i wykorzystywana informacja o tym kto dany projekt założył (\emph{właściciel})
\end{itemize}

\subsubsection{Cykl życia tasków}
Jest stały i określony z góry przez twórców aplikacji

\subsubsection{Prawa dostępu}
\begin{itemize}
	\item	Wszystkie projekty są prywatne - prawa odczytu mają jedynie użytkownicy zaproszeni
	\item	Zapraszać użytkowników mogą jedynie administratorzy danego projektu.
	\item	Użytkownicy mogą edytowac wszytkie zadania w danym projekcie, także nie swoje
	\item	Istnieje widok przepracowanego czasu pracy przez danego pracownika.\\
			Każdy ma do niego wgląd, nie tylko dany pracownik
\end{itemize}

\subsubsection{Taski}
\begin{itemize}
	\item	Brak podziału na role tester, developer, itp. w kontekście projektu.
			Jeśli jest potrzeba przetestowania pewnej funkcjonalności spisuje się na to osobnego taska,
			osoba go realizująca jest tym samym \emph{testerem} tej funkcjonalności.
	\item	Właściciel projektu jest jego administratorem. Administratorzy projektu mogą nadawać innym
			użytkownikom w projekcie rolę administratora.
	\item	Administrator może odebrać uprawnienia do projektu innym użytkownikom, w tym administratorom,
			także sobie
	\item	Jest przetrzymywana i wykorzystywana informacja o tym kto dany projekt założył (\emph{właściciel})
	\item	Doliczać godziny do danego tasku może tylko jego wykonawca
	\item	Task ma tylko i wyłącznie jednego wykonawcę
\end{itemize}


\subsection{Interfejs graficzny}
Będą dostępne następujące widoki:
\begin{itemize}
	\item	Lista projektów użytkownika
	\item	Lista tasków w projekcie
	\item	Panel administracji projektem, np: zapraszanie użytkowników,
			nadawanie zaproszonym użytkownikom praw administratora
	\item	Widok taska z komentarzami
	\item	Edycja taska, dodawanie komentarza
	\item	Widok przepracowanych godzin przez danego pracownik projektu
\end{itemize}


\chapter{Architektura systemu}

\section{Struktura aplikacji}
Jak już wcześniej wspomnieliśmy, architektura aplikacji jest podyktowana przez technologię Play! Framework. Jest to 
typowa technologia webowa oparta o wzorzec Model-View-Controller. Stąd też biorą się podstawowe nazwy pakietów: models, 
views orac controllers. \\
\begin{center}	
\vspace{4ex}	
	\includegraphics[scale=1.0]{images/tasksArch.jpg} \\
\vspace{4ex}
\end{center}

Aplikacja ma następującą strukturę katalogów:

\begin{itemize}
	\item	app - główny katalog źródłowy	
		\begin{itemize}
			\item	models - modele obiektów presystowanych. Są to klasy rozszerzającę klasę Model z framework'a
				Play! oraz oznaczone adnotacją @Entity. Są tam także Enumy i klasy pomocnicze, które są 
				persestowane wewnątrz klas @Entity.
			\item	views - widoki html'owe w plikach *.scala.html. Są to pliki korzystające z PLay'owego mechanizmu 
				"Template Engine". Silnik szablonów wykorzystuje język Scala (nie ma wersji template'ów dla Javy).
			\item	controllers - kontrolery rozszerzające play'ową klasę Controller.
			\item	security - pakiet klas odpowiedzialnych za bezpieczeństwo aplikacji i ochronę przed 
				nieupoważnionym dostępem. Komponent korzysta z mechanizmów Play! Framework i implementuje interferjsy, 
				dzięki którym można chronić dostęp do kontrolera przez dodanie adnotacji.
			\item	Global.java - klasa z ustawieniami globalnymi aplikacji.	
		\end{itemize}
	\item	conf - konfiguracja aplikacji webowej
		\begin{itemize}
			\item	application.conf - ustawienia aplikacji, takie jak konfiguracja połączenia z bazą danych, 
				czy też klucz AES do szyfrowania (np. haseł użytkowników w bazie danych)
			\item	routes - tak zwany router aplikacj Play. Jest to odwzorowanie zapytań HTML (GET, POST...) 
				na metody kontrolerów.		
		\end{itemize}
	\item	project - ustawienia projektu, głównie zależności biblioteczne
		\begin{itemize}
			\item	Build.scala - dependencje dla technologii sbt, opartej na Ivy (Apache), domyślnie wykorzystywanej 
				przez Play! Framework
			\item	plugins.sbt - wtyczki sbt
		\end{itemize}
	\item	puplic - publiczne statyczne pliki:
		\begin{itemize}
			\item	images - obrazy
			\item	botstrap - biblioteki Twitter Bootstrap
			\item	javascripts - między innymi jTable i HighCharts
			\item	stylesheets - css
		\end{itemize}
	\item	test - testy jednostkowe i integracyjne
\end{itemize}

\section{Modele}

\section{Interfejs graficzny}

\subsection{Projekt interfejsu graficznego}
Staraliśmy się zaprojektować wygodny i intuicyjny interfejs graficzny. Użytkownik powinien od początku widzieć jak 
najbardziej ogólne rzeczy i szybko przechodzić do szczegółów swojego projektu, mając jednoczesny pogląd na jak 
największą ilość elementów. Zaplanowaliśmy następującą grupę widoków:
\begin{itemize}
	\item	Widok początkowy - logowanie, rejestracja i dodatkowa zakładka z informacjami o produkcie. Wchodząc na stronę, 
		użytkownik domyślnie zobaczy zakładkę z logowaniem, ponieważ najprawdopodobniej to będzie go interesowało.
	\item	Strona główna użytkownika - jest to strona najogólniejsza. Użytkownik zobaczy tu wszystko swoje projekty. Będzie miał 
		także linka do edycji swojego profilu i wylogowywanie. Także tutaj znajdzie formularz zakładanie nowego projektu.
	\item	Strona projektu - Tutaj użytkownik przejdzie po kliknięci w link z tabelki ze swoimi projektami. Na górze będzie miał 
		zakładki z :
	\begin{itemize}
		\item	Zadaniami
		\item	Kamieniami milowymi
		\item	Współpracownikami
		\item	Wykresami pracy
	\end{itemize}
		Domyślnie załaduje się strona z zadaniami, ponieważ to ona jest najważniejsza. Zadanie, kamienie milowe i współpracownicy 
		będą prezentowane w interaktywnych tabelkach. W tabelach będą linki do stron szczegółowych odpowiednio: zadań, 
		kamieni milowych czy też współpracowników.
	\item	Strony szczegółow dla pojedynczych bytów:
	\begin{itemize}
		\item	Zadanie - Będą tu dostępne wszystkie atrybuty zadanie, wszystko w przejrzystej formie. W tabelce z zadaniami te
			dane będą mogły być prezentowane tylko skrótowo i pobieżnie. Tu natomiast będzie ładniej, dokładniej i bardziej 
			przejrzyście. Będzie także formularz dodawania komentarza. Pojawi się również historia: doytychczasowe zmiany 
			(otwieranie i zamykanie tego zadania) oraz komentarze.
		\item	Kamienień milowy - tutaj sytuacja jest bardzo podobna. Również będą zaprezentowane różne dane oraz (być może) 
			dodawanie komentarzy.
		\item	Współpracownik - Będą tu informacje o pracowniku projektu a także dane o jego pracy - liczy i wykresy.
	\end{itemize}
\end{itemize}

Prezentujemy wykres opisanego interfejsu graficznego. Uwzględniliśmy w nim generyczne widoki, przejścia między widokami oraz różne typy 
komponentów na stronie html (opisane w legendzie po lewej stronie). \\

\begin{center}	
\vspace{4ex}	
	\includegraphics[scale=0.6]{images/ui_chart.png} \\
\vspace{4ex}
\end{center}

\subsection{Technologie i biblioteki}
Implementacja webowego interfejsu graficznego wykorzystuje kilka technologii i bibliotek. Technologie są związane z 
wykorzystaną technologią webową, biblioteki natomiast są bibliotekami opartymi na JavaScript i jQuery. Technologia 
powiązana z budowaniem widoków to:
\begin{itemize}
	\item	Play! Framework Template Engine - jest to typowy mechanizm widoków w technologiach webowych MVC. 
		Widok (plik .scala.html) jest kompilowany do klasy w języku Scala. Okeśla się, jakie argumenty potrzebuje 
		dany widok do stworzenia treści strony i takie argumenty trzeba mu przekazać w statyczne metodzie render(), 
		którą wywołujemy w kontrolerach aplikacji webowej. Możliwe jest ponadto konstruowania widoku wewnątrz innego 
		widoku, dzięki czemu można stworzyć drzewkową strukturę generycznych widoków. Dalej opiszemy strukturę zależności 
		widoków w naszej aplikacji. \\
		Play! Framework Template Engine daje udostępnia zastaw tagów w języku Scala: instrukcja warunkowe, pętle itd. Mamy 
		także w zasadzie dostęp do wszystkich źródeł aplikacji a taże załączonych bibliotek, ale nie należy tego nadużywać 
		i przenosić logiki biznesowej do widoków.
\end{itemize}

Wykorzystamy również szereg bibliotek pomocniczych
\begin{itemize}
	\item	Twitter Bootstrap - bardzo popularny zestaw komponentów CSS i JavaScript. Przy minimum konfiguracji i pisania własnych 
		klas i stylów osiągnęliśmy szybko nowoczesny wygląd. W tej fazie projektu nie zamierzamy poświęcać zbyt dużo czasu 
		na wygląd aplikacji, jednak chcemy, aby strony naszego serwisu od razu przyzwoicie się prezentowały. Dodatkowo, wykorzystanie 
		Bootstrap'a da bardzo dużo możliwości w przyszłości, aby dostosować wygląd strony i rozbudować szatę graficznę. Być może, kiedyś 
		uda nam się znaleźć osobę, która poświęci więcej czasu na dopracowanie stylów CSS i zaprojektuje bardzo efektowny interfejs.
	\item	jTable - opisywaliśmy już wcześniej ten komponent. Biblioteka jest oparta na jQuery. W ramach naszych widoków musimy tylko 
		wstawić element <div>, a następnie umieścić w nim zainicjalizowanę tabelę. Tabelka wymaga podania pewnych atrybutów:
		\begin{itemize}
			\item	Linki, do któych będą przesyłane akcje: list, create, updated, delete. Będą to linki powiązane z konkretnymi 
				metodami naszych kontrolerów. Widzimy przy okazji, że tabele jTable obsługują pełny zestaw operacji CRUD 
				na przechowywanych elementach.
			\item	Kolumny tabeli: najlepiej nazwać je identycznie z nazwami pól odpowiadające klasy w modelu danych w aplikacji 
				webowej. Dzięki temu, przy akcjach tworzenia, edycji oraz usuwania Play! automatyczni powiąże dane z formularza 
				przesłanego przez jTable i stowrzy obiekt klasy z modelu danych. Dla kolumny tabeli możemy dodatkowo ustawić 
				pewne atrybuty, takie jak
				\begin{itemize}
					\item	displayValue - możemy tu manipulować wartością wyświetlaną w tabeli. Opcja jest bardzo przedatna 
						w tabeli z zadaniami, gdzie chcemy prezentować nie tylko czysty tekst, ale także różne 
						elementy graficzne, np. ikonki dla różnych rodzajów zadań czy różne kolory dla różnych priorytetów 
						zadań.
					\item	create, update - domyślnie te wartości są ustawione na true, ale zmianiając te pola na false, 
						sprawimy, że nie będzie można ich ustawić w formularzu - odpowiednio dodawania lub edcji.
					\item	list - także domyślnie true. Czasem jednak nie chcemy, aby wartość była wyświetlana w tabeli.
					\item	options - podajemy tu listę, słownik lub link, z którego w formacie JSON pobierzemy opcje w podobnym 
						formacie. Spośród tych opcji będziemy wybierać wartość pola i nie będziemy musieli wpisywać go ręcznie.
					\item	type - może być to na przykład 'date'. Dzięki temu datę w formularzu będziemy wybierać z kalendarzyka.
				\end{itemize}
			\item	Dodatkowo możemy ustawić pewne atrybuty całej tabeli, takie jak: możliwość sortowanie, domyślne sortowanie itp.
		\end{itemize}
		Wymiana danych z serwerem odbywa się za pośrednictwem formularzy i metody POST html a także za pośrednictwem JSON'a. W formacie JSON 
		przede wszystkim zwracamy dane z serwera do AJAX'owych zapytań tabeli jTable. Dla dokładniejszego poglądu przedstawiamy przykładową
		tabelę z naszego projektu, tabelę z kamieniami milowymi. Zawiera ona większość wymienionych weżej elementów. Wysztstko jest 
		wkomponowane w widok Play! Framework Template Engine: \\
		\begin{verbatim}
@projectMain("mileStones", project, scripts = jtableScript) {
<div id="MilestonesTableContainer"></div>
}

@jtableScript = {
<script type="text/javascript">
        $(document).ready(function () {
            $('#MilestonesTableContainer').jtable({
                title: 'Mile Stones',
                actions: {
                    listAction: '@routes.MileStones.list(project.id)',
                    createAction: '@routes.MileStones.create(project.id)',
                    updateAction: '@routes.MileStones.update(project.id)',
                    deleteAction: '@routes.MileStones.delete(project.id)'
                },
                fields: {
                    id: {
                        title: 'Id',
                        list: false,
                        key: true
                    },
                    name: {
                        title: 'Mile Stone',
                        display: function (data) {
                         return '<a href="' + '@routes.Projects.mileStones(project.id)' + '/' + data.record.id + '">' + data.record.name + '</a>';
                        
                        }
                    },
                    description: {
                     title: 'Description',
                     list: false,
                     type: 'textarea'
                    },
                    creationDate: {
                        title: 'Created',
                        type: 'date',
                        create: false,
                        edit: false
                    },
                    dueDate: {
                        title: 'Due Date',
                            type: 'date'
                    },
                    tasksOpened: {
                        title: 'Opened',
                        edit: false,
                        create: false
                    },
                    tasksClosed: {
                        title: 'Closed',
                        edit: false,
                        create: false
                    },
                    project: {
                        title: 'Project',
                        list: false,
                        create: false,
                        edit: false
                    },
                    progress: {
                     display: function (data) {
                     var opened = data.record.tasksOpened;
                     var closed = data.record.tasksClosed;
                     var today = new Date();
                     var due = new Date(data.record.dueDate);
                     if(opened != 0 || closed != 0) {
                         var percentage = Math.round ( (closed * 100) / (opened + closed) );
                     }
                         if(closed == 0) {
                         var percentage = 0;
                         }
                         var progrClass = "progress progress-info";
                         if(due < today) {
                         if(opened > 0)
                         var progrClass = "progress progress-danger";
                         else
                         var progrClass = "progress progress-success";
                         }
                         return '<div class="' + progrClass + '"><div class="bar" style="width: ' + percentage +'%"></div></div>'
                        },
                     create: false,
                     edit: false
                    }
                }
            });
            $('#MilestonesTableContainer').jtable('load');
        });
</script>
}
\end{verbatim}
	\item	High Charts JS - kolejna biblioteka oparta na JavaScript. Także posiada możliwość interaktywnego ładowania danych technologią AJAX.
\end{itemize}

\subsection{Struktura widoków}


%\appendix
%\chapter*{Zawartość płyty CD}
%\begin{description}
%	\item[plik dokuentacja.pdf]	 --- plik z tą dokumentacją (dodatkowo dokumentacja jest oddawana w formie drukowanej)
%	\item[folder knabees]	 --- folder z kompletnym kodem źródłowym aplikacji
%	\item[plik knabees-1.0-jar-with-dependencies.jar]	 --- plik jar zbudowanej aplikacji Javowej
%	\item[pokaz.avi]	 --- krótki filmik demonstrujący działanie aplikacji
%	\item[folder tests]		--- folder z danymi wejściowymi, oraz wykresami dla przeprowadzonych testów
%\end{description}

\addtocounter{page}{-1}

\begin{thebibliography}{9}
\bibitem{redmine}
	\href{http://www.redmine.org/projects/redmine/wiki/}{Redmine - Strona Wiki}
\bibitem{gwt}
	\href{https://developers.google.com/web-toolkit/}{Google Web Toolkit}
\bibitem{vaadin}
	\href{https://vaadin.com/book/vaadin7/-/page/architecture.html}{Vaadin Architecture}
\bibitem{play}
	\href{http://www.playframework.com/}{Play! Framework}
\bibitem{jTable}
	\href{http://jtable.org/}{jTable Plugin}
\bibitem{highcharts}
	\href{http://www.highcharts.com/}{High Charts JS}
\bibitem{bootstrap}
	\href{http://twitter.github.io/bootstrap/}{Twitter Bootstrap}
\bibitem{ebean}
	\href{http://www.avaje.org/}{Avaje Ebean}

\end{thebibliography}


\label{LastPage}\phantom{\phantomsection{LastPage}}
\end{document}
